// ===== ОБЪЕДИНЕННЫЙ ФАЙЛ: ОСНОВЫ JAVASCRIPT И ДЕСТРУКТУРИЗАЦИЯ =====
// Этот файл содержит примеры кода для разделов по основам JavaScript и деструктуризации.
// Каждый пример снабжен очень подробными комментариями на русском языке,
// чтобы даже новичок мог понять, что происходит в каждой строке.

// Выводим заголовок в консоль при загрузке скрипта.
// console.log() - это команда, которая выводит сообщение в консоль браузера (там, где разработчики видят служебную информацию).
console.log("===== ОСНОВЫ JAVASCRIPT И ДЕСТРУКТУРИЗАЦИЯ =====");

// === Переменные и типы данных ===
// Переменные - это как коробочки, в которых мы храним информацию.
// Типы данных - это то, какая информация лежит в коробочке (число, текст, правда/ложь и т.д.).

// Выводим подзаголовок в консоль.
console.log("\n--- Типы данных ---"); // \n создает новую строку в выводе консоли.

// Объявление Переменных: Как создать "коробочку".
// let: Используется для создания коробочек, содержимое которых (значение) может меняться со временем.
let message = "Привет"; // Создали коробочку message и положили туда текст "Привет".

// const: Используется для создания "неизменяемых" коробочек (констант).
// Значение, которое мы положили туда в самом начале, нельзя будет поменять позже.
const PI = 3.14;        // Создали коробочку PI и положили туда число 3.14. Это значение останется таким навсегда.

// var: Устаревший способ создания коробочек. В современном коде его стараются не использовать,
// потому что let и const более предсказуемы и безопасны.
var oldWay = "Устаревший способ"; // Создали коробочку oldWay и положили туда текст.

// Основные типы данных в JavaScript: Какие "вещи" мы можем хранить в наших "коробочках".

// String (Строка): Это просто текст. Всегда пишется в кавычках (одинарных '', двойных "" или обратных ``).
let string = "Это строка";              // В коробочке string лежит текст "Это строка".

// Number (Число): Это числа. Могут быть целыми (как 42) или с точкой (как 3.14).
let number = 42;                        // В коробочке number лежит число 42.

// BigInt: Для очень-очень больших целых чисел, которые обычный Number уже не может точно хранить.
// Объявляется добавлением буквы 'n' в конце числа.
let bigInt = 9007199254740991n;         // В коробочке bigInt лежит очень большое число.

// Boolean (Логический тип): Может хранить только два значения: true (правда) или false (ложь).
// Используется для проверки условий.
let boolean = true;                     // В коробочке boolean лежит значение "правда".

// Null: Специальное значение, которое означает "ничего", "пусто" или "значение неизвестно".
// Разработчик сам присваивает null, чтобы явно показать, что значение отсутствует.
let nullValue = null;                   // В коробочке nullValue лежит "ничего".

// Undefined: Значение, которое переменная получает АВТОМАТИЧЕСКИ, если ей ничего не присвоили при создании.
let undefinedValue;                     // Создали коробочку undefinedValue, но ничего в нее не положили. Там теперь undefined.

// Object (Объект): Это более сложная "коробочка", которая может хранить много разных "вещей" (свойств)
// в формате "имя_вещи: значение_вещи". Свойства заключаются в фигурные скобки {}.
let object = { name: "John", age: 30 }; // Создали объект с двумя свойствами: name (значение "John") и age (значение 30).

// Array (Массив): Особый вид объекта, предназначенный для хранения УПОРЯДОЧЕННОЙ коллекции элементов.
// Элементы хранятся по порядку и имеют номер (индекс), начиная с 0. Элементы заключаются в квадратные скобки [].
let array = [1, 2, 3];                  // Создали массив с тремя числами: 1 (под номером 0), 2 (под номером 1), 3 (под номером 2).

// Function (Функция): Блок кода, который выполняет определенную задачу, когда мы его "вызываем".
// Функции в JavaScript тоже считаются объектами.
let func = function () { return "Hi"; }; // Создали функцию, которая при вызове вернет текст "Hi".

// Проверка типа данных с помощью оператора typeof (вывод в консоль)
// typeof - это специальное слово, которое помогает узнать, какой тип данных хранится в коробочке или у значения.
// typeof возвращает строку с названием типа.
console.log(typeof string);      // Проверяем тип string. Выведет "string".
console.log(typeof number);      // Проверяем тип number. Выведет "number".
console.log(typeof boolean);     // Проверяем тип boolean. Выведет "boolean".
console.log(typeof nullValue);   // Проверяем тип nullValue. Выведет "object". (Это известная историческая ошибка в JavaScript, typeof null возвращает "object" вместо "null").
console.log(typeof undefinedValue); // Проверяем тип undefinedValue. Выведет "undefined".
console.log(typeof object);      // Проверяем тип object. Выведет "object".
console.log(typeof array);       // Проверяем тип array. Выведет "object" (массивы в JS считаются объектами).
console.log(typeof func);        // Проверяем тип func. Выведет "function".

// === Операторы ===
// Операторы - это символы или слова, которые выполняют действия над значениями (например, складывают числа или сравнивают их).

// Выводим подзаголовок в консоль.
console.log("\n--- Операторы ---");

// Арифметические операторы: Используются для математических вычислений.
let sum = 5 + 3;        // Оператор + (сложение): 5 + 3 = 8. Результат 8 записывается в коробочку sum.
let difference = 5 - 3;  // Оператор - (вычитание): 5 - 3 = 2. Результат 2 записывается в коробочку difference.
let product = 5 * 3;     // Оператор * (умножение): 5 * 3 = 15. Результат 15 записывается в коробочку product.
let quotient = 10 / 2;   // Оператор / (деление): 10 / 2 = 5. Результат 5 записывается в коробочку quotient.
let remainder = 10 % 3;  // Оператор % (остаток от деления): 10 разделить на 3 будет 3 и остаток 1. Результат 1 записывается в коробочку remainder.
let power = 2 ** 3;      // Оператор ** (возведение в степень): 2 в степени 3 (2*2*2) = 8. Результат 8 записывается в коробочку power.
// Выводим результаты арифметических операций через console.log().
console.log("Арифметика:", sum, difference, product, quotient, remainder, power);

// Операторы сравнения: Используются для сравнения значений. Всегда возвращают true (правда) или false (ложь).
console.log("Сравнение:");
console.log("5 > 3:", 5 > 3);      // Оператор > (больше): 5 больше 3? Правда (true).
console.log("5 < 3:", 5 < 3);      // Оператор < (меньше): 5 меньше 3? Ложь (false).
console.log("5 >= 5:", 5 >= 5);     // Оператор >= (больше или равно): 5 больше или равно 5? Правда (true).
console.log("5 <= 3:", 5 <= 3);     // Оператор <= (меньше или равно): 5 меньше или равно 3? Ложь (false).
// == (нестрогое равно): Сравнивает значения, пытаясь преобразовать их к одному типу, если они разные.
console.log('5 == "5":', 5 == "5");   // Число 5 и строка "5". JS попытается преобразовать "5" в число 5. 5 равно 5? Правда (true).
// === (строгое равно): Сравнивает значения ТОЛЬКО если их типы ОДИНАКОВЫЕ. Если типы разные, сразу false.
console.log('5 === "5":', 5 === "5");  // Число 5 и строка "5". Типы разные (number и string). Сразу ложь (false).
// != (нестрогое не равно): Проверяет, что значения НЕ равны (с приведением типов). Противоположность ==.
console.log('5 != "5":', 5 != "5");   // 5 не равно "5"? JS преобразует "5" в 5. 5 не равно 5? Ложь (false).
// !== (строгое не равно): Проверяет, что значения СТРОГО НЕ равны (без приведения типов). Противоположность ===.
console.log('5 !== "5":', 5 !== "5");  // 5 строго не равно "5"? Типы разные. Правда (true).

// Логические операторы: Используются для работы с логическими значениями (true/false) или для объединения условий.
console.log("Логика:");
// && (Логическое И - AND): Результат true, только если ОБА условия (или значения) истинны.
console.log("true && false:", true && false); // true И false? Ложь (false).
// || (Логическое ИЛИ - OR): Результат true, если ХОТЯ БЫ ОДНО условие (или значение) истинно.
console.log("true || false:", true || false); // true ИЛИ false? Правда (true).
// ! (Логическое НЕ - NOT): Инвертирует логическое значение. !true становится false, !false становится true.
console.log("!true:", !true);         // НЕ правда? Ложь (false).

// Инкремент (++) и декремент (--) операторы: Специальные операторы для увеличения (++) или уменьшения (--) значения переменной на 1.
console.log("Инкремент/Декремент:");
let i = 5;
// Постфиксный инкремент (i++): Сначала используется ТЕКУЩЕЕ значение переменной (в console.log выведется 5),
// а УВЕЛИЧЕНИЕ на 1 происходит ПОСЛЕ этой операции.
console.log("i++:", i++);  // Выведет 5. После этой строки i станет 6.
console.log("i после i++:", i);    // Теперь i равно 6.
let j = 5;
// Префиксный инкремент (++j): Сначала УВЕЛИЧИВАЕТ переменную на 1 (j становится 6),
// а затем используется НОВОЕ значение переменной (в console.log выведется 6).
console.log("++j:", ++j);  // j становится 6, затем выведет 6.
console.log("j после ++j:", j);    // Теперь j равно 6.

// === Строки и шаблонные строки ===
// Строки - это текст. Шаблонные строки - более удобный способ работы с текстом.

// Выводим подзаголовок в консоль.
console.log("\n--- Строки ---");

// Конкатенация строк: Соединение (склеивание) строк с помощью оператора +.
let firstName = "John"; // Строка "John".
let lastName = "Doe";   // Строка "Doe".
let fullName = firstName + " " + lastName; // Соединяем "John", пробел (" ") и "Doe". Получаем "John Doe".
console.log("Полное имя:", fullName); // Выведет "Полное имя: John Doe".

// Шаблонные строки (template literals): Используют обратные кавычки (`) вместо одинарных или двойных.
// Главное удобство - можно легко вставлять переменные или результаты выражений прямо в строку, используя синтаксис ${...}.
let greeting = `Привет, ${firstName} ${lastName}!`; // Вставляем значения переменных firstName и lastName прямо в строку.
let calculation = `2 + 2 = ${2 + 2}`; // Вставляем результат вычисления выражения 2 + 2 (получится 4).
console.log("Шаблонная строка:", greeting); // Выведет "Шаблонная строка: Привет, John Doe!".
console.log("Вычисление в строке:", calculation); // Выведет "Вычисление в строке: 2 + 2 = 4".

// Многострочные шаблонные строки: Шаблонные строки могут занимать несколько строк в коде, и переводы строк сохранятся в итоговой строке.
let multiline = `Это первая строка.
Это вторая строка.
А это третья строка.`; // Текст занимает три строки в коде.
// Выводим многострочную строку. \n в console.log добавлено для переноса строки перед выводом, чтобы отделить от предыдущего вывода.
console.log("Многострочная строка:\n", multiline); // Выведет текст в несколько строк.

// === Методы строк ===
// Методы строк - это встроенные функции, которые "принадлежат" строкам и позволяют выполнять над ними различные действия.

let text = "Привет, мир!"; // Исходная строка для примеров.

// Получение длины строки: Свойство .length возвращает количество символов в строке.
console.log("Длина строки:", text.length);            // Выведет 12 (включая пробел и восклицательный знак).

// Получение символа по индексу: Доступ к символу по его номеру (индексу). Индексация начинается с 0 (первый символ имеет индекс 0).
console.log(text[0]); // Выведет "П" (символ по индексу 0).
console.log(text.charAt(0)); // То же самое, но с использованием метода charAt(). Выведет "П".

// Поиск подстроки:
console.log("Поиск 'мир':", text.indexOf("мир"));    // Метод indexOf("подстрока") ищет "подстрока" внутри строки text
// и возвращает ИНДЕКС (номер), с которого начинается первое совпадение. Если не найдено, возвращает -1. Выведет 8 (буква 'м' находится на 8-й позиции, считая с 0).
console.log("Содержит 'Привет':", text.includes("Привет"));   // Метод includes("подстрока") проверяет, содержит ли строка указанную "подстрока". Возвращает true или false. Выведет true.

// Извлечение подстроки: Как вырезать часть строки.
console.log(text.substring(0, 6)); // Метод substring(startIndex, endIndex) извлекает часть строки ОТ startIndex ДО endIndex (не включая символ по endIndex). Выведет "Привет" (символы с индексом 0 по 5).
console.log("Извлечение 'мир':", text.slice(8, 11));      // Метод slice(startIndex, endIndex) работает похоже на substring, но может принимать отрицательные индексы. Выведет "мир" (символы с индексом 8 по 10).

// Замена подстроки: Метод replace(searchValue, newValue) заменяет ПЕРВОЕ вхождение searchValue (что ищем) на newValue (на что меняем).
console.log("Замена 'мир':", text.replace("мир", "JavaScript")); // Найдет первое "мир" и заменит на "JavaScript". Выведет "Привет, JavaScript!".

// Преобразование регистра: Изменение букв на заглавные или строчные.
console.log("Верхний регистр:", text.toUpperCase()); // Метод toUpperCase() преобразует ВСЕ символы строки в верхний регистр. Выведет "ПРИВЕТ, МИР!".
console.log("Нижний регистр:", text.toLowerCase()); // Метод toLowerCase() преобразует ВСЕ символы строки в нижний регистр. Выведет "привет, мир!".

// Удаление пробелов в начале и конце: Метод trim() удаляет пробельные символы (пробелы, табы, переводы строк) только в НАЧАЛЕ и КОНЦЕ строки.
let paddedText = "   Текст с пробелами   "; // Строка с пробелами по краям.
console.log("Удаление пробелов:", paddedText.trim()); // Выведет "Текст с пробелами" (пробелы по краям удалены).

// Разделение строки на массив: Метод split(separator) разбивает строку на массив подстрок, используя указанный разделитель.
console.log("Разбиение по ', ':", "яблоко,банан,киви".split(",")); // Разделяем строку каждый раз, когда встречается запятая. Выведет ["яблоко", "банан", "киви"] (массив из трех строк).

// === Условные конструкции ===
// Условные конструкции позволяют программе принимать решения: выполнять разный код в зависимости от того, истинно условие или ложно.

// Выводим подзаголовок в консоль.
console.log("\n--- Условия ---");

// if-else: Самая простая условная конструкция.
let age = 20; // Переменная age равна 20.
if (age >= 18) { // Проверяем условие: age больше или равно 18? (20 >= 18) -> Правда (true).
  // Если условие в if истинно, выполняется код внутри этих фигурных скобок.
  console.log("Вы совершеннолетний"); // Этот код выполнится.
} else { // Если условие в if ложно, выполняется код внутри этих фигурных скобок (блок else).
  // Этот код не выполнится, потому что условие if было истинно.
  console.log("Вы несовершеннолетний");
}

// if-else if-else: Позволяет проверять несколько условий последовательно.
let score = 85; // Переменная score равна 85.
if (score >= 90) { // Проверяем первое условие: score больше или равно 90? (85 >= 90) -> Ложь (false).
  // Этот блок пропускается.
  console.log("Оценка: Отлично");
} else if (score >= 70) { // Если первое условие ложно, проверяем второе: score больше или равно 70? (85 >= 70) -> Правда (true).
  // Условие истинно, выполняется код внутри этих фигурных скобок else if.
  console.log("Оценка: Хорошо"); // Этот код выполнится.
} else if (score >= 50) { // Этот блок не будет проверен, потому что предыдущее условие (score >= 70) было истинно.
  console.log("Оценка: Удовлетворительно");
} else { // Этот блок выполнится, если ни одно из предыдущих условий (if и else if) не было истинно.
  console.log("Оценка: Неудовлетворительно");
}

// Тернарный оператор (? :): Сокращенная форма if-else для очень простых случаев, когда нужно выбрать одно из двух значений.
// Синтаксис: условие ? значение_если_true : значение_если_false;
let status = age >= 18 ? "Взрослый" : "Ребенок"; // Условие age >= 18 истинно (20 >= 18).
// Если условие истинно, выбирается первое значение ("Взрослый").
// Если бы условие было ложно, выбралось бы второе значение ("Ребенок").
console.log("Статус:", status); // Выведет "Статус: Взрослый".

// switch: Используется для выбора одного блока кода из множества вариантов на основе точного значения переменной или выражения.
let day = 3; // Переменная day равна 3.
let dayName; // Создаем переменную для названия дня.
switch (day) { // Начинаем проверять значение переменной day.
  case 1: // Если day ТОЧНО равно 1:
    dayName = "Понедельник"; // Присваиваем dayName значение "Понедельник".
    break; // break - очень важное слово! Оно говорит JS выйти из switch после выполнения этого case. Если его не поставить, JS продолжит проверять и выполнять код в следующих case!
  case 2: // Если day ТОЧНО равно 2:
    dayName = "Вторник";
    break;
  case 3: // Если day ТОЧНО равно 3: (Наше day равно 3, поэтому этот case совпадет)
    dayName = "Среда"; // Присваиваем dayName значение "Среда".
    break; // Выходим из switch.
  case 4: // Этот и последующие case не будут проверены, так как мы вышли из switch.
    dayName = "Четверг";
    break;
  case 5:
    dayName = "Пятница";
    break;
  case 6:
    dayName = "Суббота";
    break;
  case 7:
    dayName = "Воскресенье";
    break;
  default: // Если значение day не совпало НИ с одним из case выше:
    dayName = "Неизвестный день"; // Выполняется код в блоке default.
}
console.log("День недели:", dayName); // Выведет "День недели: Среда".

// === Преобразование типов ===
// Преобразование типов - это когда JavaScript меняет тип данных одного значения на другой (например, из числа в строку).
// Это может происходить автоматически (неявно) или по нашей команде (явно).

// Выводим подзаголовок в консоль.
console.log("\n--- Преобразование типов ---");

// Строковое преобразование: Превращаем что-то в строку (текст).
let num = 42; // Число 42.
let strFromNum = String(num); // Явное преобразование: Используем функцию String() для превращения числа 42 в строку "42".
let strFromBool = String(true); // Явное преобразование: Превращаем булево значение true в строку "true".
console.log("Число в строку:", strFromNum, typeof strFromNum); // Выведет "Число в строку: 42 string".
console.log("Булево в строку:", strFromBool, typeof strFromBool); // Выведет "Булево в строку: true string".

// Числовое преобразование: Превращаем что-то в число.
let str = "42"; // Строка "42".
let strFloat = "42.5"; // Строка "42.5".
let strInvalid = "Привет"; // Строка "Привет".
let numFromStr = Number(str);   // Явное преобразование: Используем функцию Number() для превращения строки "42" в число 42.
let numFromFloat = Number(strFloat); // Явное преобразование: Превращаем строку "42.5" в число 42.5.
let numFromInvalid = Number(strInvalid); // Явное преобразование: Пытаемся превратить строку "Привет" в число. Не получается, потому что это не число. Результат - NaN (Not a Number - Не число).
let numFromBoolTrue = Number(true); // Явное преобразование: Превращаем булево true в число. true становится 1.
let numFromBoolFalse = Number(false); // Явное преобразование: Превращаем булево false в число. false становится 0.
console.log('Строка "42" в число:', numFromStr, typeof numFromStr); // Выведет 'Строка "42" в число: 42 number'.
console.log('Строка "42.5" в число:', numFromFloat, typeof numFromFloat); // Выведет 'Строка "42.5" в число: 42.5 number'.
console.log('Строка "Привет" в число:', numFromInvalid, typeof numFromInvalid); // Выведет 'Строка "Привет" в число: NaN number'.
console.log("true в число:", numFromBoolTrue); // Выведет "true в число: 1".
console.log("false в число:", numFromBoolFalse); // Выведет "false в число: 0".

// Также существуют специальные функции parseInt() и parseFloat() для извлечения чисел из строк,
// которые могут содержать нечисловые символы в конце.
console.log("parseInt('42px'):", parseInt("42px")); // parseInt() читает строку С НАЧАЛА и останавливается, как только встретит НЕ числовой символ ('p'). Возвращает прочитанную числовую часть. Выведет 42.
console.log("parseFloat('42.5em'):", parseFloat("42.5em")); // parseFloat() работает так же, но учитывает десятичную точку. Выведет 42.5.

// Логическое преобразование: Превращаем что-то в булево значение (true или false).
console.log("Логическое преобразование:");
console.log("Boolean(1):", Boolean(1));     // Явное преобразование: Используем функцию Boolean(). Число 1 (любое ненулевое число) становится true. Такие значения называются "truthy" (истинные).
console.log("Boolean(0):", Boolean(0));     // Явное преобразование: Число 0 становится false. Такие значения называются "falsy" (ложные).
console.log('Boolean(""):', Boolean(""));    // Явное преобразование: Пустая строка "" становится false.
console.log('Boolean("text"):', Boolean("text")); // Явное преобразование: Любая непустая строка становится true.
console.log("Boolean(null):", Boolean(null));  // null становится false.
console.log("Boolean(undefined):", Boolean(undefined)); // undefined становится false.
console.log("Boolean(NaN):", Boolean(NaN)); // NaN становится false.
console.log("Boolean({}):", Boolean({})); // Любой объект (даже пустой {}) становится true.
console.log("Boolean([]):", Boolean([])); // Любой массив (даже пустой []) становится true.

// === Деструктуризация объектов ===
// Деструктуризация - это удобный способ быстро "вытащить" значения из объектов или массивов
// и присвоить их отдельным переменным.

// Выводим подзаголовок в консоль.
console.log("\n--- Деструктуризация объектов ---");

// Простой пример деструктуризации объекта.
// Создаем объект user с свойствами name и age.
const user = {
  name: "Jacob",
  age: 32
};

// Деструктуризация объекта:
// const { name, age } = user;
// Фигурные скобки {} слева от знака = указывают на деструктуризацию объекта.
// name: Мы хотим извлечь свойство с именем 'name' из объекта user и создать новую переменную С ТЕМ ЖЕ ИМЕНЕМ 'name'.
// age: Мы хотим извлечь свойство с именем 'age' из объекта user и создать новую переменную С ТЕМ ЖЕ ИМЕНЕМ 'age'.
// = user: Указывает, из какого объекта мы извлекаем свойства.
const { name, age: userAge } = user;

// Теперь у нас есть две новые переменные name и age, содержащие значения из объекта user.
// Выводим значения извлеченных переменных.
console.log(name); // Выведет "Jacob"
console.log(age);  // Выведет 32

// Пример деструктуризации объекта со значениями по умолчанию и переименованием.
// Создаем объект book с свойствами title и author. Свойства coverImage в нем нет.
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell"
};

// Деструктуризация с переименованием и значением по умолчанию:
// { title } - Извлекаем свойство 'title' в переменную 'title'.
// { author: bookAuthor } - Извлекаем свойство 'author' и ПЕРЕИМЕНОВЫВАЕМ его в 'bookAuthor'. Теперь мы будем использовать переменную bookAuthor.
// { coverImage = "..." } - Пытаемся извлечь свойство 'coverImage'. Если его нет в объекте 'book' (как в этом случае),
// переменной 'coverImage' будет присвоено значение по умолчанию, указанное после знака равенства (=).
const { title, author: bookAuthor, coverImage = "https://via.placeholder.com/640/480" } = book;

// Выводим значения извлеченных переменных.
console.log(title);     // Выведет "The Last Kingdom"
console.log(bookAuthor); // Выведет "Bernard Cornwell" (используем новое имя переменной bookAuthor)
console.log(coverImage); // Выведет значение по умолчанию ("https://via.placeholder.com/640/480"), так как свойства coverImage нет в объекте book.

// Пример деструктуризации объектов в цикле for...of.
// Деструктуризация очень удобна при переборе массивов, содержащих объекты.
// Создаем массив объектов, где каждый объект представляет книгу с свойствами title, author и rating.
const books = [
  { title: "The Last Kingdom", author: "Bernard Cornwell", rating: 8.38 },
  { title: "Beside Still Waters", author: "Robert Sheckley", rating: 8.51 }
];

// Перебираем массив books с помощью цикла for...of.
// for (const { title, author, rating } of books) { ... }
// В каждой итерации цикла, вместо того чтобы получать весь объект книги (например, 'const book of books'),
// мы сразу ДЕСТРУКТУРИРУЕМ объект текущей книги прямо в круглых скобках после 'const'.
// { title, author, rating } - извлекает свойства title, author и rating из текущего объекта книги в отдельные переменные с теми же именами.
for (const { title, author, rating } of books) {
  // Используем извлеченные переменные для вывода информации о каждой книге.
  console.log(`Книга: ${title}, Автор: ${author}, Рейтинг: ${rating}`);
}
// Результат будет:
// Книга: The Last Kingdom, Автор: Bernard Cornwell, Рейтинг: 8.38
// Книга: Beside Still Waters, Автор: Robert Sheckley, Рейтинг: 8.51

// Пример деструктуризации параметров функции (объект).
// Деструктуризацию можно использовать прямо в списке параметров функции.
// Объявляем функцию printUserInfo.
// function printUserInfo({ name, age, hobby }) { ... }
// В параметрах функции мы ожидаем ОДИН ОБЪЕКТ. Вместо того чтобы объявлять один параметр (например, 'userData')
// и затем внутри функции писать 'const { name, age, hobby } = userData;', мы делаем это сразу в сигнатуре функции:
// { name, age, hobby } - это деструктуризация входящего объекта.
// Это означает, что функция ОЖИДАЕТ объект, который имеет свойства name, age и hobby.
// Эти свойства будут АВТОМАТИЧЕСКИ извлечены в ЛОКАЛЬНЫЕ переменные name, age и hobby, доступные внутри функции.
function printUserInfo({ name, age, hobby }) {
  // Используем извлеченные переменные name, age и hobby внутри функции.
  console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);
}

// Вызываем функцию printUserInfo, передавая ей объект как аргумент.
// Свойства этого объекта (name, age, hobby) будут автоматически деструктурированы в параметры функции.
printUserInfo({
  name: "Alice",
  age: 25,
  hobby: "dancing"
});
// Выведет: Name: Alice, Age: 25, Hobby: dancing

// Пример глубокой деструктуризации объектов (вложенные объекты).
// Если объект содержит другие объекты внутри себя, можно деструктурировать их свойства на любом уровне вложенности.
// Создаем объект userWithStats с вложенным объектом stats.
const userWithStats = { // Переименовал переменную, чтобы избежать конфликта с предыдущим примером user.
  name: "Jacques Gluke",
  tag: "jgluke",
  stats: { // Вложенный объект stats со статистикой пользователя.
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

// Глубокая деструктуризация:
// const { name: userName, tag, stats: { followers, views, likes } } = userWithStats;
// { name: userName } - Извлекаем свойство 'name' из userWithStats и переименовываем его в 'userName'.
// { tag } - Извлекаем свойство 'tag' из userWithStats в переменную 'tag'.
// { stats: { followers, views, likes } } - Это часть для деструктуризации ВЛОЖЕННОГО объекта.
// stats: - указывает, что мы хотим работать со свойством 'stats' объекта userWithStats.
// { followers, views, likes } - внутри этих фигурных скобок мы указываем свойства, которые хотим извлечь ИЗ объекта stats.
// В результате будут созданы переменные userName, tag, followers, views, likes.
const { name: userName, tag, stats: { followers, views, likes } } = userWithStats; // Переименовал name в userName для ясности.

// Выводим значения извлеченных переменных.
console.log(userName);     // Выведет "Jacques Gluke" (извлечено из userWithStats.name)
console.log(tag);      // Выведет "jgluke" (извлечено из userWithStats.tag)
console.log(followers); // Выведет 5603 (извлечено из userWithStats.stats.followers)
console.log(views);     // Выведет 4827 (извлечено из userWithStats.stats.views)
console.log(likes);     // Выведет 1308 (извлечено из userWithStats.stats.likes)

// Важно понимать: при такой глубокой деструктуризации, как показано выше, переменная 'stats' НЕ создается.
// Если вам нужна САМА переменная stats (как объект), нужно деструктурировать ее отдельно:
// const { name, tag, stats } = userWithStats; // Теперь stats - это объект { followers: 5603, views: 4827, likes: 1308 }
// И затем, если нужно, можно деструктурировать уже этот объект stats:
// const { followers, views, likes } = stats;

// === Деструктуризация массивов ===
// Деструктуризация массивов позволяет "вытащить" элементы массива по их позиции и присвоить их переменным.

// Выводим подзаголовок в консоль.
console.log("\n--- Деструктуризация массивов ---");

// Простой пример деструктуризации массива.
// Создаем массив color с тремя элементами (значения RGB цвета).
const color = [200, 255, 100];

// Деструктуризация массива:
// const [red, green, blue] = color;
// Квадратные скобки [] слева от знака = указывают на деструктуризацию массива.
// red: Первая переменная red получит значение ПЕРВОГО элемента массива color (color[0]).
// green: Вторая переменная green получит значение ВТОРОГО элемента массива color (color[1]).
// blue: Третья переменная blue получит значение ТРЕТЬЕГО элемента массива color (color[2]).
// = color: Указывает, из какого массива мы извлекаем элементы.
// ПОРЯДОК переменных в квадратных скобках ВАЖЕН при деструктуризации массивов.
const [red, green, blue] = color;

// Используем извлеченные переменные.
console.log(`rgb(${red}, ${green}, ${blue})`); // Выведет "rgb(200, 255, 100)"

// Пример деструктуризации массива со значениями по умолчанию.
// Если при деструктуризации массива переменных больше, чем элементов в массиве,
// переменным, для которых нет соответствующего элемента, будет присвоено значение undefined.
// Мы можем задать значения по умолчанию для таких случаев.
// Создаем массив colorWithAlpha с тремя элементами.
const colorWithAlpha = [200, 100, 255]; // Переименовал переменную для ясности.

// Деструктуризация массива со значением по умолчанию:
// [redColor, greenColor, blueColor, alfa = 0.3] = colorWithAlpha;
// Извлекаем redColor, greenColor, blueColor как раньше (они получат значения 200, 100, 255).
// Для переменной alfa мы указываем значение по умолчанию = 0.3 после знака =.
// Так как в массиве colorWithAlpha НЕТ четвертого элемента, переменной alfa будет присвоено значение по умолчанию 0.3.
const [redColor, greenColor, blueColor, alfa = 0.3] = colorWithAlpha; // Переименовал переменные для ясности.

// Используем извлеченные значения.
console.log(`rgba(${redColor}, ${greenColor}, ${blueColor}, ${alfa})`); // Выведет "rgba(200, 100, 255, 0.3)"

// Пример использования оператора rest (...) при деструктуризации массивов.
// Оператор rest позволяет собрать ВСЕ ОСТАВШИЕСЯ элементы массива в новый массив.
// Создаем массив moreColors с несколькими элементами.
const moreColors = [200, 255, 100, 50, 150]; // Переименовал переменную.

// Деструктуризация с оператором rest:
// [firstColor, ...otherColors] = moreColors;
// Извлекаем первый элемент (200) в переменную firstColor.
// ...otherColors - оператор rest (...) перед именем переменной otherColors говорит:
// "Собери ВСЕ ОСТАВШИЕСЯ элементы из массива moreColors (после первого, который уже взят в firstColor)
// и помести их в НОВЫЙ МАССИВ под названием otherColors".
const [firstColor, ...otherColors] = moreColors; // Переименовал переменные для ясности.

// Выводим извлеченные значения.
console.log(firstColor);        // Выведет 200 (первый элемент).
console.log(otherColors); // Выведет [255, 100, 50, 150] (новый массив с оставшимися элементами).

// Пример пропуска значений при деструктуризации массива.
// Если вам нужно извлечь не первый или второй элемент, а, например, только третий,
// можно "пропустить" ненужные элементы, оставляя пустые места между запятыми в квадратных скобках.
// Создаем массив rgbValues значений.
const rgbValues = [200, 100, 255]; // Переименовал переменную.

// Деструктуризация с пропуском значений:
// [ , , blueValue ] = rgbValues;
// Первая запятая пропускает первый элемент (200).
// Вторая запятая пропускает второй элемент (100).
// Переменная blueValue получит значение ТРЕТЬЕГО элемента массива (255), потому что она стоит на третьей позиции (после двух пропусков).
const [, , blueValue] = rgbValues; // Переименовал переменную для ясности.

// Выводим извлеченное значение.
console.log(`Blue: ${blueValue}`); // Выведет "Blue: 255".

// Пример деструктуризации параметров функции (массив).
// Деструктуризацию массива можно использовать прямо в списке параметров функции,
// если функция ожидает массив в качестве аргумента.
// Объявляем функцию printFruits.
// function printFruits([firstFruit, secondFruit, thirdFruit]) { ... }
// В параметрах функции мы ожидаем ОДИН МАССИВ. Мы деструктурируем его прямо в сигнатуре функции:
// [firstFruit, secondFruit, thirdFruit] - это деструктуризация входящего массива.
// Это означает, что функция ОЖИДАЕТ массив, и его первый, второй и третий элементы
// будут АВТОМАТИЧЕСКИ извлечены в ЛОКАЛЬНЫЕ переменные firstFruit, secondFruit и thirdFruit соответственно,
// доступные внутри функции.
function printFruits([firstFruit, secondFruit, thirdFruit]) {
  // Используем извлеченные переменные внутри функции.
  console.log(firstFruit, secondFruit, thirdFruit);
}

// Вызываем функцию printFruits, передавая ей массив как аргумент.
// Элементы этого массива будут деструктурированы в параметры функции.
printFruits(["apple", "banana", "orange"]); // Выведет: apple banana orange

// Если передать массив с меньшим количеством элементов, переменные, для которых нет соответствия, будут undefined.
// printFruits(["grape", "kiwi"]); // Выведет: grape kiwi undefined

// === Логика для выполнения примеров на странице ===
// Этот блок кода не относится напрямую к основам JS или деструктуризации,
// но он нужен для того, чтобы примеры на вашей HTML-странице работали.
// Он отвечает за обработку нажатий кнопок "Запустить пример" и вывод результатов выполнения кода в специальный блок на странице.

// document.querySelectorAll('.run-code') - Находит ВСЕ элементы на HTML-странице, у которых есть класс 'run-code' (это наши кнопки).
// .forEach(button => { ... }) - Перебирает каждый найденный элемент (каждую кнопку) и выполняет для него следующий код.
document.querySelectorAll('.run-code').forEach(button => {
  // button - это текущая кнопка, которую мы обрабатываем в цикле.

  // Добавляем "слушателя" события 'click' (нажатие мыши) к текущей кнопке.
  // Когда пользователь нажмет на эту кнопку, выполнится функция, указанная внутри addEventListener.
  button.addEventListener('click', () => {
    // При нажатии на кнопку происходит следующее:

    // Ищем элемент <code>, который находится внутри элемента <pre>,
    // который в свою очередь является РОДИТЕЛЬСКИМ элементом для текущей кнопки.
    // В элементе <code> хранится сам код примера.
    const codeElement = button.parentElement.querySelector('pre code');
    // Ищем элемент <div> с классом 'output', который находится рядом с кнопкой (в том же родительском элементе).
    // В этот div мы будем выводить результаты выполнения кода (то, что обычно видно в консоли).
    const outputDiv = button.parentElement.querySelector('.output');

    // Проверяем, найдены ли элементы codeElement и outputDiv.
    // Если хотя бы один не найден (например, ошибка в структуре HTML),
    // выводим предупреждение в консоль браузера и выходим из функции, чтобы избежать ошибок.
    if (!codeElement || !outputDiv) {
      console.warn("Не найдены элементы 'pre code' или 'div.output' для кнопки 'Запустить'.");
      return; // Выходим из функции.
    }

    // Получаем значение атрибута 'data-example' у кнопки.
    // Это может быть полезно для идентификации примера, но в данной логике выполнения кода не используется.
    const exampleId = button.getAttribute('data-example');
    // Очищаем содержимое div.output перед выполнением нового кода, чтобы не смешивать результаты разных запусков.
    outputDiv.innerHTML = '';

    // --- Перехват console.log для вывода в div.output ---
    // Этот блок временно изменяет работу console.log, чтобы его вывод попадал не только в консоль браузера, но и на страницу.

    // Сохраняем оригинальную функцию console.log в переменной originalConsoleLog, чтобы потом ее вернуть обратно.
    const originalConsoleLog = console.log;
    // Создаем пустой массив logs, в который будем собирать все сообщения, переданные в console.log.
    const logs = [];

    // Переопределяем стандартную функцию console.log на нашу собственную.
    // Теперь, когда в коде примера вызывается console.log(...), будет выполняться ЭТА функция.
    console.log = (...args) => { // ...args означает, что функция может принимать любое количество аргументов.
      // Форматируем аргументы, переданные в console.log, чтобы они хорошо выглядели при выводе на страницу.
      const formattedArgs = args.map(arg => { // Перебираем каждый аргумент, переданный в console.log.
        // Если аргумент является объектом (и не null), пытаемся преобразовать его в строку JSON для лучшего отображения структуры объекта.
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg, null, 2); // Преобразуем объект в форматированную строку JSON с отступами (null, 2).
          } catch (e) { return '[Circular Object]'; } // Если объект содержит ссылки сам на себя (циклические ссылки), JSON.stringify вызовет ошибку. В этом случае выводим заглушку '[Circular Object]'.
        }
        // Для всех остальных типов (чисел, строк, булевых и т.д.) просто преобразуем аргумент в строку.
        return String(arg);
      });
      // Объединяем отформатированные аргументы одной строкой, разделяя их пробелом, и добавляем эту строку в массив logs.
      logs.push(formattedArgs.join(' '));
      // Вызываем ОРИГИНАЛЬНУЮ функцию console.log (которую мы сохранили в начале),
      // чтобы сообщения также выводились в стандартную консоль браузера (это полезно для отладки).
      originalConsoleLog.apply(console, args); // apply используется для вызова функции с заданным контекстом (console) и аргументами в виде массива.
    };
    // --- Конец перехвата console.log ---

    try {
      // Блок try...catch...finally используется для обработки ошибок.
      // Код внутри try выполняется. Если происходит ошибка, выполнение переходит в блок catch.
      // Блок finally выполняется всегда, независимо от того, была ошибка или нет.

      // Выполняем код из блока <code>.
      // Получаем текстовое содержимое элемента <code> (сам код примера).
      const codeText = codeElement.textContent;
      // Создаем новую функцию из текста кода.
      // new Function(codeText) - это способ выполнить строку кода как JavaScript. Это относительно безопасный способ для выполнения кода, введенного пользователем или взятого из доверенного источника.
      const userCode = new Function(codeText);
      // Вызываем созданную функцию для выполнения кода примера.
      userCode();

      // После выполнения кода примера, выводим собранные логи (сообщения из console.log) в div.output на странице.
      if (logs.length > 0) {
        // Если есть собранные логи (массив logs не пустой), перебираем их.
        logs.forEach(log => {
          // Для каждого сообщения из логов создаем новый HTML-элемент параграфа <p>.
          const p = document.createElement('p');
          // Устанавливаем текст этого параграфа равным сообщению из лога.
          p.textContent = log;
          // Добавляем созданный параграф в div.output на странице.
          outputDiv.appendChild(p);
        });
      } else {
        // Если массив logs пустой (то есть в коде примера не было вызовов console.log),
        // выводим сообщение о том, что код выполнен без вывода.
        const p = document.createElement('p');
        p.textContent = "Код выполнен без вывода в console.log.";
        p.style.fontStyle = "italic"; // Делаем текст курсивом для отличия.
        outputDiv.appendChild(p);
      }
    } catch (error) {
      // Если при выполнении кода внутри блока try произошла ЛЮБАЯ ошибка, выполнение переходит сюда, в блок catch.
      // error - это объект, содержащий информацию об ошибке.
      const p = document.createElement('p');
      // Выводим сообщение об ошибке в div.output на странице.
      p.textContent = `Ошибка выполнения: ${error.message}`; // error.message содержит текстовое описание ошибки.
      p.style.color = '#ff5555'; // Делаем текст ошибки красным, чтобы он был заметен.
      outputDiv.appendChild(p);
    } finally {
      // Блок finally выполняется ВСЕГДА после try...catch, независимо от того, была ошибка или нет.
      // Здесь мы ВОССТАНАВЛИВАЕМ оригинальную функцию console.log. Это КРАЙНЕ ВАЖНО,
      // чтобы console.log снова работал как обычно для других частей вашего сайта.
      console.log = originalConsoleLog;
    }
  });
});
// --- Логика для выполнения примеров на странице arrays.html ---
document.querySelectorAll('.run-code').forEach(button => {
  button.addEventListener('click', () => {
    // Находим ближайший родительский '.code-block'
    const codeBlock = button.closest('.code-block');
    if (!codeBlock) return; // Если не нашли блок кода, выходим


    // Ищем элемент <code> внутри <pre> в этом блоке
    const codeElement = codeBlock.querySelector('pre code');
    // Ищем div для вывода результата в этом блоке
    const outputDiv = codeBlock.querySelector('.output');

    // Проверяем, что нашли и код, и место для вывода
    if (!codeElement || !outputDiv) {
      console.warn("Не найдены элементы 'pre code' или 'div.output' для кнопки 'Запустить'.");
      return;
    }

    // Очищаем предыдущий результат вывода
    outputDiv.innerHTML = '';
    // Добавляем класс для стилизации (например, рамка во время выполнения)
    outputDiv.classList.add('output--active');

    // Сохраняем оригинальную функцию console.log, чтобы не сломать ее глобально
    const originalConsoleLog = console.log;
    // Создаем массив для сбора всех вызовов console.log во время выполнения кода примера
    const logs = [];

    // Временно ПЕРЕОПРЕДЕЛЯЕМ console.log
    console.log = (...args) => {
      // Форматируем аргументы для вывода (объекты превращаем в JSON-строки)
      const formattedArgs = args.map(arg => {
        if (typeof arg === 'object' && arg !== null) {
          try {
            // Пытаемся преобразовать объект в читаемую строку JSON
            // `null, 2` добавляет отступы для красивого вывода
            return JSON.stringify(arg, null, 2);
          } catch (e) {
            // Обработка ошибки, если объект циклический (ссылается сам на себя)
            return '[Circular Object]';
          }
        }
        // Если это не объект, просто преобразуем в строку
        return String(arg);
      });
      // Добавляем отформатированную строку лога в наш массив `logs`
      logs.push(formattedArgs.join(' ')); // Объединяем аргументы через пробел, если их несколько

      // Вызываем оригинальный console.log, чтобы лог все еще появлялся в консоли разработчика
      originalConsoleLog.apply(console, args);
    };

    try {
      // Получаем текстовое содержимое элемента <code> (это и есть код для выполнения)
      const codeText = codeElement.textContent;
      // Создаем новую анонимную функцию из текста кода.
      // Это безопаснее, чем eval(), так как код выполняется в своем контексте.
      const userCode = new Function(codeText);
      // Выполняем созданную функцию (т.е. код из примера)
      userCode();

      // Выводим собранные логи в `outputDiv`
      if (logs.length > 0) {
        // Если были логи, создаем для каждого параграф <p> и добавляем в div
        logs.forEach(log => {
          const p = document.createElement('p');
          p.textContent = log;
          outputDiv.appendChild(p);
        });
      } else {
        // Если логов не было, выводим сообщение об этом
        const p = document.createElement('p');
        p.textContent = "Код выполнен без вывода в console.log.";
        p.style.fontStyle = "italic"; // Делаем текст курсивом
        outputDiv.appendChild(p);
      }
    } catch (error) {
      // Если во время выполнения кода произошла ошибка
      const p = document.createElement('p');
      p.textContent = `Ошибка выполнения: ${error.message}`; // Показываем сообщение об ошибке
      p.style.color = 'var(--error-color, #ff5555)'; // Красный цвет для ошибки (используем переменную CSS, если есть)
      outputDiv.appendChild(p);
      // Также выводим ошибку в настоящую консоль для детальной отладки
      originalConsoleLog("Ошибка в примере:", error);
    } finally {
      // ВАЖНО: В любом случае (успех или ошибка) ВОССТАНАВЛИВАЕМ оригинальный console.log
      console.log = originalConsoleLog;
      // Можно убрать класс активности после выполнения (опционально)
      // setTimeout(() => outputDiv.classList.remove('output--active'), 500);
    }
  });
});
// --- Логика для кнопки "Скопировать код" ---
document.querySelectorAll('.copy-code').forEach(button => {
  button.addEventListener('click', async () => {
    const codeBlock = button.closest('.code-block');
    if (!codeBlock) return;
    const codeElement = codeBlock.querySelector('pre code');
    if (!codeElement) return;

    // Получаем текст кода ИЗ HTML
    const codeToCopy = codeElement.textContent;
    try {
      // Используем современный Clipboard API для копирования
      await navigator.clipboard.writeText(codeToCopy);
      // Даем обратную связь пользователю
      const originalText = button.textContent;
      button.textContent = 'Скопировано!';
      button.disabled = true; // Блокируем кнопку на время
      setTimeout(() => {
        button.textContent = originalText;
        button.disabled = false; // Разблокируем кнопку
      }, 1500); // Через 1.5 секунды возвращаем текст и активность
    } catch (err) {
      console.error('Ошибка копирования:', err);
      // Можно добавить сообщение об ошибке для пользователя
      const originalText = button.textContent;
      button.textContent = 'Ошибка!';
      setTimeout(() => {
        button.textContent = originalText;
      }, 1500);
    }
  });
});
// --- Логика для кнопки "Скрыть/Показать код" ---
document.querySelectorAll('.toggle-code').forEach(button => {
  button.addEventListener('click', () => {
    const codeBlock = button.closest('.code-block');
    if (!codeBlock) return;
    const preElement = codeBlock.querySelector('pre'); // Находим <pre> внутри блока
    if (!preElement) return;

    // Переключаем видимость элемента <pre> с кодом
    if (preElement.style.display === 'none') {
      preElement.style.display = ''; // Возвращаем значение по умолчанию (обычно 'block'), чтобы показать
      button.textContent = 'Скрыть код'; // Обновляем текст кнопки
    } else {
      preElement.style.display = 'none'; // Скрываем элемент
      button.textContent = 'Показать код'; // Обновляем текст кнопки
    }
  });
});
// ===== Файл: js/10_dom_summary.js =====
// Этот файл содержит логику для кнопок "Запустить пример" на странице dom_summary.html.
// Он НЕ содержит сам код примеров DOM API (он находится в HTML),
// Reported,
// а только вызывает нужный код из объекта 'examples' при нажатии соответствующей кнопки.
// Также здесь реализован перехват console.log для вывода в блок .output.
// --- Объект с кодом примеров ---
// Ключи объекта соответствуют значениям атрибута 'data-example' у кнопок.
// Значения - это функции, содержащие код соответствующего примера DOM API.
// Этот код будет выполняться при нажатии кнопки "Запустить пример".
const examples = {
  // --- Код для примера "Поиск элементов" ---
  "search-elements": () => {
    console.log("===== 1. Поиск DOM-элементов =====");
    const heading = document.querySelector("h1");
    console.log("Первый заголовок (document.querySelector('h1')):", heading);
    const items = document.querySelectorAll(".item");
    console.log("Все элементы с классом '.item' (document.querySelectorAll('.item')):", items);
    items.forEach((item, index) => {
      console.log(` Найденный элемент .item[${index}]:`, item);
    });
    const mainElement = document.querySelector("main");
    if (mainElement) {
      const firstParagraphInMain = mainElement.querySelector("p");
      console.log("\nПервый параграф внутри <main> (mainElement.querySelector('p')):", firstParagraphInMain);
    } else {
      console.log("\nЭлемент <main> не найден.");
    }
  },
  // --- Код для примера "Навигация по DOM" ---
  "dom-navigation": () => {
    console.log("===== 2. Навигация по DOM =====");
    const ul = document.createElement("ul");
    const li1 = document.createElement("li");
    li1.textContent = "Элемент 1";
    li1.id = "item-1";
    const li2 = document.createElement("li");
    li2.textContent = "Элемент 2";
    li2.id = "item-2";
    ul.append(li1, li2);
    console.log("Создана временная структура:", ul.outerHTML);
    console.log("\nРодитель li1 (li1.parentElement):", li1.parentElement);
    console.log("Дети ul (ul.children):", ul.children);
    console.log("Первый дочерний элемент ul (ul.firstElementChild):", ul.firstElementChild);
    console.log("Последний дочерний элемент ul (ul.lastElementChild):", ul.lastElementChild);
    console.log("Следующий соседний элемент для li1 (li1.nextElementSibling):", li1.nextElementSibling);
    console.log("Предыдущий соседний элемент для li2 (li2.previousElementSibling):", li2.previousElementSibling);
    console.log("Предыдущий соседний элемент для li1 (li1.previousElementSibling):", li1.previousElementSibling);
    console.log("Следующий соседний элемент для li2 (li2.nextElementSibling):", li2.nextElementSibling);
  },
  // --- Код для примера "Свойства элемента" ---
  "element-properties": () => {
    console.log("===== 3. Свойства DOM-элемента =====");
    const div = document.createElement("div");
    div.innerHTML = "<p>Это <strong>важный</strong> текст.</p>";
    console.log("Создан div:", div.outerHTML);
    console.log("\ntextContent:");
    console.log(" Чтение:", div.textContent);
    div.textContent = "Новый <span>простой</span> текст.";
    console.log(" После записи textContent (innerHTML):", div.innerHTML);
    div.innerHTML = "<p>Это <strong>важный</strong> текст.</p>";
    console.log("\ninnerHTML:");
    console.log(" Чтение:", div.innerHTML);
    div.innerHTML = "<ul><li>Новый</li><li>список</li></ul>";
    console.log(" После записи innerHTML:", div.innerHTML);
    console.log("\nstyle:");
    div.style.backgroundColor = "lightblue";
    div.style.padding = "15px";
    console.log(" style.backgroundColor:", div.style.backgroundColor);
    console.log(" style.padding:", div.style.padding);
    console.log("\nАтрибуты:");
    div.setAttribute("id", "my-div");
    div.setAttribute("data-status", "active");
    console.log(" HTML после setAttribute:", div.outerHTML);
    console.log(" Есть ли атрибут 'id' (hasAttribute)?", div.hasAttribute("id"));
    console.log(" Значение 'id' (getAttribute):", div.getAttribute("id"));
    console.log(" Значение 'data-status' (getAttribute):", div.getAttribute("data-status"));
    console.log(" Значение 'data-status' (dataset.status):", div.dataset.status);
    div.dataset.status = "inactive";
    console.log(" Значение 'data-status' после изменения через dataset:", div.getAttribute("data-status"));
    div.removeAttribute("id");
    console.log(" Атрибут 'id' удалён (hasAttribute)?", !div.hasAttribute("id"));
    console.log(" HTML после removeAttribute:", div.outerHTML);
  },
  // --- Код для примера "CSS-классы" ---
  "css-classes": () => {
    console.log("===== 4. Управление CSS-классами =====");
    const box = document.createElement("div");
    box.classList.add("box");
    console.log("Начальные классы (box.className):", box.className);
    console.log("\ncontains:");
    console.log(" Есть ли класс 'box'?", box.classList.contains("box"));
    console.log(" Есть ли класс 'active'?", box.classList.contains("active"));
    console.log("\nadd 'active':");
    box.classList.add("active");
    console.log(" Классы после добавления 'active':", box.className);
    box.classList.add("highlighted", "important");
    console.log(" Классы после добавления 'highlighted', 'important':", box.className);
  }
};

// --- Конец файла basics_combined.js ---
