```html
<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Объяснение синхронного и асинхронного кода, setTimeout, setInterval, Date, Promise, then, catch, finally. Сравнение колбэков и промисов, промисификация. Работа с множеством промисов: Promise.all, Promise.allSettled, Promise.race.">
    <meta name="keywords"
        content="JavaScript, синхронный, асинхронный, setTimeout, setInterval, Date, время, дата, getTime, Date.now, геттеры, сеттеры, Промисы, Promise, then, catch, finally, цепочки промисов, колбэки, промисификация, Promise.all, Promise.allSettled, Promise.race">
    <meta name="author" content="Ваше Имя или Ник">
    <link rel="icon" href="../favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css"
        integrity="sha512-rz9zzlK5wN/vC/r2R7kK3XqW9xT320Pz30g3/72W8g3w5d5m5s2y30v3w20/4k0f20l80z8l8e30d30l8e"
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Raleway:wght@700&family=Roboto:wght@400;500;600;700&display=swap"
        rel="stylesheet" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
    <!-- Ссылка на основной стиль. Проверь путь! -->
    <link rel="stylesheet" href="../css/style.css" />

    <title>Синхронность и Асинхронность в JS</title>
</head>

<body>
    <div id="progress-bar"></div>
    < <header>
        <div class="header-container">
            <div class="logo"></div>
            <a href="index.html">
                <h1>JavaScript</h1>
            </a>

            <button id="theme-toggle" aria-label="Переключить тему">
                Светлая тема
            </button>
            <!-- Кнопка бургер-меню (появляется на мобильных по CSS) -->
            <button id="menu-toggle" class="menu-toggle-btn" aria-label="Открыть меню" aria-expanded="false">
                ☰
            </button>

            <!-- Основная навигация -->
            <nav id="main-nav">
                <!-- Кнопка закрытия меню (появляется в модальном окне по CSS) -->
                <button id="menu-close" class="menu-close-btn" aria-label="Закрыть меню">
                    ×
                </button>
                <!-- Убедитесь, что этот UL имеет ID -->
                <ul id="main-nav-list">
                    <li><a href="../index.html">Главная</a></li>
                    <li><a href="learning_guide.html">Гайд по обучению</a></li>
                    <li><a href="basics_combined.html" class="active animate-neon-fill">Основы и Деструктуризация</a>
                    </li>
                    <li><a href="arrays.html">Массивы</a></li>
                    <li><a href="functions.html">Функции</a></li>
                    <li><a href="loops.html">Циклы</a></li>
                    <li><a href="objects.html">Объекты</a></li>
                    <li><a href="oop-classes.html">ООП и классы</a></li>
                    <li><a href="modules4_page.html">JSON, Хранилище, Инструменты, Модули</a></li>
                    <li><a href="exercises.html">Упражнения</a></li>
                    <li><a href="projects.html">Проекты</a></li>
                    <li><a href="resources.html">Ресурсы</a></li>
                    <li><a href="dom_summary.html">Памятка по DOM</a></li>
                    <li><a href="gallery.html">Галерея(пример)</a></li>
                    <li><a href="async.html" class="active animate-neon-fill">Синхронность/Асинхронность</a></li>
                </ul>
            </nav>
        </div>
        </header>
        <main class="container">
            <h2 id="async-intro">Что такое синхронный и асинхронный код?</h2>
            <section class="scroll-reveal">
                <h3>Синхронный код</h3>
                <p>Синхронный код выполняется последовательно: каждая команда ждёт, пока выполнится предыдущая. Это как
                    очередь за билетами — ты не можешь купить билет, пока человек перед тобой не закончит покупку.</p>
                <p>Пример синхронного кода:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Синхронный код =====
// Этот код выполняется СТРОГО по порядку, сверху вниз.
// console.log("...") - это функция для вывода сообщения в консоль браузера.
console.log("Первое сообщение"); // Эта строка выполнится первой и сразу выведет "Первое сообщение". Программа ждёт завершения этой операции.
// Только после полного завершения предыдущей строки, выполняется эта строка.
console.log("Второе сообщение"); // Эта строка выполнится второй и выведет "Второе сообщение". Программа снова ждёт.
// Только после полного завершения предыдущей строки, выполняется эта строка.
console.log("Третье сообщение"); // Эта строка выполнится третьей и выведет "Третье сообщение".
// После завершения этой строки программа переходит к следующему коду (если он есть).
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Первое сообщение
Второе сообщение
Третье сообщение</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>console.log</code> — это метод, который выводит текст в консоль браузера.</li>
                    <li>Каждый <code>console.log</code> выполняется один за другим, поэтому мы видим сообщения в том же
                        порядке, в котором они написаны.</li>
                    <li>Программа не переходит к следующей строке, пока не завершит выполнение текущей.</li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Асинхронный код</h3>
                <p>Асинхронный код позволяет запускать операции, которые не блокируют выполнение программы. Например, ты
                    можешь отправить запрос на сервер и, не дожидаясь ответа, выполнять другой код. Это как в ресторане:
                    ты
                    заказываешь еду, но не сидишь и не ждёшь, пока её приготовят, а можешь разговаривать или пить кофе.
                </p>
                <p>Пример асинхронного кода с <code>setTimeout</code>:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Асинхронный код с setTimeout =====
// Этот код демонстрирует неблокирующее выполнение.
// Выводим первое сообщение - это синхронная операция, выполняется сразу.
console.log("Первое сообщение"); // Эта строка выполняется НЕМЕДЛЕННО и выводит "Первое сообщение".

// Планируем асинхронную операцию с задержкой 2 секуды.
// setTimeout() - это встроенная функция JavaScript, которая выполняет код один раз после указанной задержки.
// Она является АСИНХРОННОЙ: она НЕ ОСТАНАВЛИВАЕТ выполнение остального кода.
setTimeout(() => { // Первый аргумент setTimeout - это функция (callback), которую нужно выполнить после задержки. Используем стрелочную функцию.
  // --- Код внутри этой функции (callback) ---
  // Этот код будет выполнен ТОЛЬКО ПОСЛЕ истечения задержки, когда браузер вызовет эту функцию.
  console.log("Второе сообщение"); // Этот console.log выведется через 2000 мс.
}, 2000); // Второй аргумент setTimeout - это ЗАДЕРЖКА в миллисекундах (2000 мс = 2 секунды).

// Выводим третье сообщение - это синхронная операция, выполняется сразу.
// Эта строка выполняется НЕМЕДЛЕННО после того, как setTimeout ПЛАНИРУЕТ выполнение колбэка.
// Она не ждет, пока сработает таймер setTimeout, так как планирование неблокирующее.
console.log("Третье сообщение"); // Этот console.log выведется сразу после "Первое сообщение".

// Таким образом, порядок вывода в консоль будет "Первое", "Третье", а затем (через 2 секунды) "Второе".
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Первое сообщение
Третье сообщение
Второе сообщение</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>console.log("Первое сообщение")</code> — выполняется сразу, выводит "Первое сообщение".
                    </li>
                    <li><code>setTimeout(() => {...}, 2000)</code> — это асинхронная функция, которая планирует
                        выполнение
                        кода через 2 секунды. Она не останавливает программу, а просто "ставит задачу в очередь".</li>
                    <li><code>() => {...}</code> — это стрелочная функция (arrow function), которая является коротким
                        способом записи функции в JavaScript. Она работает так же, как обычная функция, но имеет более
                        компактный синтаксис. В данном случае она содержит код
                        <code>console.log("Второе сообщение")</code>.
                    </li>
                    <li><code>2000</code> — задержка в миллисекундах (2 секунды), после которой стрелочная функция
                        выполнится.</li>
                    <li><code>console.log("Третье сообщение")</code> — выполняется сразу после <code>setTimeout</code>,
                        поэтому выводится раньше, чем "Второе сообщение".</li>
                    <li>Через 2 секунды <code>setTimeout</code> вызывает стрелочную функцию, и мы видим "Второе
                        сообщение".
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Почему так?</h3>
                <p>JavaScript — однопоточный язык, то есть в один момент времени выполняется только одна операция. Но
                    асинхронность позволяет "отложить" выполнение некоторых задач (как <code>setTimeout</code>) в
                    специальную очередь (event loop / web APIs), которую браузер обрабатывает, когда основной
                    (синхронный)
                    код завершён.</p>

                <h3>Зачем нужна асинхронность?</h3>
                <p>Асинхронность важна для операций, которые занимают много времени, например:</p>
                <ul>
                    <li>Запросы к серверу (получение данных с сайта).</li>
                    <li>Чтение файлов.</li>
                    <li>Ожидание событий (например, клик мыши).</li>
                    <li>Таймеры (<code>setTimeout</code>, <code>setInterval</code>).</li>
                </ul>
                <p>Если бы эти операции были синхронными, программа бы "зависала", пока они не завершатся. Асинхронность
                    позволяет программе оставаться отзывчивой (responsive), например, реагировать на действия
                    пользователя
                    или анимацию, пока грузятся данные.</p>

                <p><strong>Аналогия:</strong></p>
                <ul>
                    <li><strong>Синхронность:</strong> ты готовишь кофе, и пока оно не готово, не можешь делать ничего
                        другого.</li>
                    <li><strong>Асинхронность:</strong> ты ставишь кофе вариться, а сам идёшь мыть посуду. Когда кофе
                        готов,
                        ты его забираешь.</li>
                </ul>
            </section>
            <!-- Конец первого блока материала -->

            <!-- ============================================ -->
            <!-- Начало второго блока материала: Дата -->
            <!-- ============================================ -->
            <h2 id="async-date">Создание даты</h2>
            <section class="scroll-reveal">
                <p>В JavaScript для работы с датами используется встроенный класс <code>Date</code>. Он позволяет
                    представлять моменты времени как объекты и управлять ими с помощью специальных методов. С помощью
                    <code>Date</code> можно создавать часы, таймеры, календари и другие интерактивные элементы
                    интерфейса.
                </p>

                <h3>Создание объекта Date</h3>
                <p>Экземпляр класса <code>Date</code> — это объект, который фиксирует определённый момент времени. Если
                    создать объект <code>Date</code> без аргументов, он вернёт текущие дату и время, основанные на
                    системных
                    часах компьютера.</p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Создание объекта Date (текущее время) =====
// Создаём новый объект Date без аргументов.
// Этот конструктор БЕЗ аргументов возвращает объект, представляющий ТОЧНО текущий момент времени.
const date = new Date(); // Например, Date { Sat May 10 2025 12:34:56 GMT+0300 (...) }

// Выводим созданный объект Date в консоль.
// JavaScript автоматически преобразует объект Date в читаемую строку для вывода в консоль,
// используя метод toString() и учитывая локальный часовой пояс компьютера.
console.log(date); // Например: "Sat May 10 2025 12:34:56 GMT+0300 (Eastern European Summer Time)"

// Формат вывода зависит от настроек часового пояса на компьютере, но сам объект хранит точное время.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (будет текущая дата и время):</p>
                <pre><code class="language-text">Sat May 10 2025 12:34:56 GMT+0200 (Eastern European Standard Time)</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>new Date()</code> — создаёт новый объект <code>Date</code>, который представляет текущий
                        момент времени.</li>
                    <li><code>console.log(date)</code> — выводит объект <code>Date</code> в консоль. При этом объект
                        автоматически преобразуется в строку с помощью метода <code>toString()</code>, который
                        возвращает
                        дату и время в читаемом формате, включая часовой пояс.</li>
                    <li>Формат вывода зависит от настроек часового пояса на компьютере.</li>
                </ul>
                <p>Ответ на вопрос: <strong>Что будет результатом вызова <code>new Date()</code> без
                        аргументов?</strong>
                </p>
                <pre><code class="language-text">Ответ: Объект, представляющий текущие дату и время.</code></pre>
            </section>

            <section class="scroll-reveal">
                <h3>Установка даты</h3>
                <p>Класс <code>Date</code> позволяет задавать дату и время разными способами: через строки или числовые
                    значения. Давай разберём, как это работает.</p>

                <h4>Создание даты через строку</h4>
                <p>Можно передать в <code>Date</code> строку, описывающую дату и время. Формат строки гибкий, но обычно
                    используется формат ISO: ГГГГ-ММ-ДД (для даты) или ГГГГ-ММ-ДДTЧЧ:ММ:СС (для даты и времени).</p>

                <p>Пример 1: Только дата (формат ISO)</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Создание Date через строку (ГГГГ-ММ-ДД) =====
// Создаём объект Date, передавая строку с датой в формате ISO 8601 ("YYYY-MM-DD").
const date = new Date("2030-03-16"); // Год 2030, месяц 03 (март), день 16.

// Выводим полученный объект Date в консоль.
// Время не указано в строке, поэтому оно автоматически устанавливается на 00:00:00 (полночь) в часовом поясе UTC.
// Однако, при выводе в консоль, дата преобразуется в строку с учетом ЛОКАЛЬНОГО часового пояса,
// поэтому время может выглядеть не как 00:00:00 UTC, а как 00:00:00 + смещение вашего пояса.
console.log(date); // Например: "Sat Mar 16 2030 00:00:00 GMT+0200 (Eastern European Standard Time)"
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Sat Mar 16 2030 00:00:00 GMT+0200 (Eastern European Standard Time)</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>"2030-03-16"</code> — строка, где 2030 — год, 03 — месяц (март), 16 — день.</li>
                    <li>Время не указано, поэтому оно автоматически устанавливается на 00:00:00 (полночь) в часовом
                        поясе,
                        который зависит от интерпретации строки (обычно UTC для этого формата). При выводе в консоль оно
                        адаптируется к локальному поясу.</li>
                </ul>

                <p>При пример 2: Дата и время (формат ISO)</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Создание Date через строку (ГГГГ-ММ-ДДTЧЧ:ММ:СС) =====
// Создаём объект Date, передавая строку с датой и временем в формате ISO 8601.
// 'T' разделяет дату и время. '14:25:00' - это 2 часа 25 минут дня.
const date = new Date("2030-03-16T14:25:00");

// Выводим полученный объект Date в консоль.
// Дата и время указаны точно, поэтому они будут представлены с учетом локального часового пояса.
console.log(date); // Например: "Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>"2030-03-16T14:25:00"</code> — строка, где T разделяет дату и время. Здесь указано
                        14:25:00
                        (2:25 дня).</li>
                    <li>Формат ISO удобен, так как он стандартизирован и широко используется.</li>
                </ul>

                <p>Пример 3: Гибкость формата строки</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Гибкость формата строк для Date =====
// Можно передавать строки с разной степенью детализации.
console.log("Создание даты только по году:");
// Если передать только год, дата по умолчанию станет 1 января этого года, время - полночь UTC.
console.log(new Date("2030")); // Например: "Tue Jan 01 2030 02:00:00 GMT+0200" (с учетом локального пояса)

console.log("\nСоздание даты по году и месяцу:");
// Если передать год и месяц, день по умолчанию станет 1-е число месяца, время - полночь UTC.
console.log(new Date("2030-03")); // Например: "Fri Mar 01 2030 02:00:00 GMT+0200"

console.log("\nСоздание даты по году, месяцу, дню:");
// Если передать год, месяц и день, время по умолчанию станет полночь UTC.
console.log(new Date("2030-03-16")); // Например: "Sat Mar 16 2030 02:00:00 GMT+0200"

console.log("\nСоздание даты по году, месяцу, дню, времени (ISO):");
// Полный формат ISO задаёт точную дату и время.
console.log(new Date("2030-03-16T14:25:00")); // Например: "Sat Mar 16 2030 14:25:00 GMT+0200"

// Можно использовать и другие форматы строк, но ISO предпочтительнее для надежности.
// Например: new Date("March 16, 2030 14:25:00")
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Создание даты только по году:
Tue Jan 01 2030 02:00:00 GMT+0200
Создание даты по году и месяцу:
Fri Mar 01 2030 02:00:00 GMT+0200
Создание даты по году, месяцу, дню:
Sat Mar 16 2030 02:00:00 GMT+0200
Создание даты по году, месяцу, дню, времени (ISO):
Sat Mar 16 2030 14:25:00 GMT+0200</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li>Если указан только год ("2030"), <code>Date</code> автоматически установит 1 января и время по
                        умолчанию (полночь UTC, с адаптацией к локальному поясу при выводе).</li>
                    <li>Если указан год и месяц ("2030-03"), день устанавливается на 1-е число.</li>
                    <li>Полный формат ("2030-03-16T14:25:00") задаёт точную дату и время.</li>
                </ul>

                <h4>Создание даты через числа</h4>
                <p>Другой способ — передать в <code>Date</code> числовые значения для года, месяца, дня, часов, минут,
                    секунд и миллисекунд. Обязательны только первые три параметра (год, месяц, день).</p>
                <p><strong>Важно:</strong> в JavaScript месяцы нумеруются с 0 (0 — январь, 1 — февраль, ..., 11 —
                    декабрь).
                </p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Создание Date через числа =====
// Создаём объект Date, передавая числовые параметры в определённом порядке:
// new Date(год, месяц, день, часы, минуты, секунды, миллисекунды)
// Год: 2030
// Месяц: 2 (т.е. март, т.к. нумерация с 0)
// День: 16
// Часы: 14
// Минуты: 25
// Секунды: 0
// Миллисекунды: 0
const date = new Date(2030, 2, 16, 14, 25, 0, 0); // Все аргументы числовые

// Выводим полученный объект Date в консоль.
// Дата и время будут отображены с учетом локального часового пояса.
console.log(date); // Например: "Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"

// Если не указать необязательные параметры (часы, минуты, секунды, миллисекунды), они по умолчанию будут равны 0.
console.log("\nДата без указания времени:");
console.log(new Date(2030, 2, 16)); // Время будет 00:00:00 локального часового пояса (или 02:00:00 GMT+0200)
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)
Fecha sin especificar hora:
Sat Mar 16 2030 00:00:00 GMT+0200 (Eastern European Standard Time)</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li>2030 — год.</li>
                    <li>2 — месяц (Важно: в JavaScript месяцы нумеруются с 0 (0 — январь, 1 — февраль, ..., 11 —
                        декабрь).
                        Поэтому 2 означает март).</li>
                    <li>16 — день месяца.</li>
                    <li>14, 25, 0, 0 — время: 14 часов, 25 минут, 0 секунд, 0 миллисекунд.</li>
                    <li>Если не указать необязательные параметры (часы, минуты, секунды, миллисекунды), они будут
                        установлены на 0.</li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Unix-время и <code>getTime()</code> / <code>Date.now()</code></h3>
                <p><strong>Unix-время (или timestamp)</strong> — это количество миллисекунд, прошедших с полуночи 1
                    января
                    1970 года по UTC (Coordinated Universal Time). Это стандартный способ представления времени в
                    компьютерах.</p>

                <h4>Создание даты через Unix-время</h4>
                <p>Если передать в <code>Date</code> одно число, оно интерпретируется как количество миллисекунд с 1
                    января
                    1970 года.</p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Создание Date через Unix-время =====
// Unix-время 0 соответствует 00:00:00 UTC 1 января 1970 года.
// Создаём объект Date, передавая число 0.
const dateZero = new Date(0);
// Выводим результат. Время будет отображено с учетом ЛОКАЛЬНОГО часового пояса.
console.log("Дата с Unix-временем 0:", dateZero); // Например: "Thu Jan 01 1970 03:00:00 GMT+0300" (если ваш пояс GMT+3)

// Создаём объект Date, передавая число 15000.
// Это означает 15000 миллисекунд (или 15 секунд) после 00:00:00 UTC 1 января 1970 года.
const datePlus15s = new Date(15000);
// Выводим результат.
console.log("Дата с Unix-временем 15000:", datePlus15s); // Например: "Thu Jan 01 1970 03:00:15 GMT+0300"

// Unix-время - это всегда число, и оно НЕ зависит от часового пояса!
// Объект Date затем адаптирует это число к локальному поясу при отображении.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (зависит от вашего часового пояса):</p>
                <pre><code class="language-text">Дата с Unix-временем 0: Thu Jan 01 1970 03:00:00 GMT+0300
Дата с Unix-временем 15000: Thu Jan 01 1970 03:00:15 GMT+0300</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>new Date(0)</code> — создаёт объект <code>Date</code>, представляющий 1 января 1970 года,
                        00:00:00 UTC. Время в консоли может отличаться из-за часового пояса (например, GMT+0300).</li>
                    <li><code>new Date(15000)</code> — добавляет 15 секунд к начальной точке, поэтому время становится
                        00:00:15 UTC (снова с адаптацией к локальному поясу при выводе).</li>
                </ul>

                <h4>Метод <code>getTime()</code></h4>
                <p>Метод <code>getTime()</code> возвращает Unix-время (количество миллисекунд с 1 января 1970 года по
                    UTC)
                    для объекта <code>Date</code>.</p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Метод getTime() =====
// Создаём объект Date с текущей датой и временем.
const date = new Date(); // Например: Date { Sat May 10 2025 12:34:56 GMT+0300 (...) }

// Получаем числовое представление этого момента времени в виде Unix-времени (миллисекунд с 1970-01-01 00:00:00 UTC).
const timestamp = date.getTime();

// Выводим полученное Unix-время в консоль.
console.log("Unix-время для текущего момента (миллисекунды с 1970):", timestamp); // Например: 1741622496123 (большое число)

// Это числовое значение не зависит от часового пояса и уникально для каждого момента времени.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (будет большое число, соответствующее текущему моменту):</p>
                <pre><code class="language-text">Unix-время для текущего момента (миллисекунды с 1970): 1741622496123</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>date.getTime()</code> — возвращает число, представляющее количество миллисекунд от 1
                        января
                        1970 года до момента, который хранит объект <code>date</code>.</li>
                    <li>Это число уникально, так как время всегда движется вперёд, и два разных момента не могут иметь
                        одинаковый timestamp.</li>
                </ul>
                <p>Зачем нужен Unix-время?</p>
                <ul>
                    <li>Оно удобно для хранения и сравнения дат, так как это просто число.</li>
                    <li>Не зависит от форматов дат, строк или часовых поясов.</li>
                    <li>Используется для измерения интервалов времени, логирования событий и т.д.</li>
                </ul>

                <h4>Метод <code>Date.now()</code></h4>
                <p>Метод <code>Date.now()</code> — это быстрый способ получить **текущее** Unix-время **без создания
                    объекта** <code>Date</code>.</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Метод Date.now() =====
// Статический метод Date.now() класса Date.
// Возвращает числовое значение - количество миллисекунд, прошедших с 1 января 1970 года UTC до ТЕКУЩЕГО момента.
const time = Date.now(); // Например: 1741622496123

// Выводим полученное число в консоль.
console.log("Текущее Unix-время (Date.now()):", time); // Выведет текущий timestamp.

// Этот метод проще и быстрее, чем new Date().getTime().
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (будет большое число, соответствующее текущему моменту):</p>
                <pre><code class="language-text">Текущее Unix-время (Date.now()): 1741622496123</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>Date.now()</code> — статический метод класса <code>Date</code>, который возвращает
                        количество
                        миллисекунд с 1 января 1970 года до текущего момента.</li>
                    <li>Это быстрее, чем создавать объект <code>Date</code> и вызывать <code>getTime()</code>.</li>
                </ul>

                <h4>Пример: Измерение времени выполнения кода</h4>
                <p><code>Date.now()</code> часто используется для измерения времени, например, чтобы узнать, сколько
                    времени
                    заняло выполнение кода.</p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Измерение времени выполнения кода =====
// Измерим, сколько времени занимает выполнение простого цикла.

// --- Фиксируем время начала ---
// Получаем текущее Unix-время (миллисекунд с 1970 года) в начале выполнения кода.
const startTime = Date.now(); // Например, 1741622496123

// --- Выполняем код, время которого хотим измерить ---
console.log("Начало выполнения цикла...");
// Запускаем простой цикл, который просто выводит числа от 0 до 100.
for (let i = 0; i <= 100; i += 1) {
  // Тело цикла:
  console.log("   Выполнение итерации:", i); // Выводим текущее значение счетчика.
}
console.log("Конец выполнения цикла.");
// --- Фиксируем время окончания ---
// Получаем текущее Unix-время после завершения цикла.
const endTime = Date.now(); // Например, 1741622496133

// --- Вычисляем разницу ---
// Разница между временем окончания и временем начала даст нам время выполнения в миллисекундах.
const elapsedTime = endTime - startTime; // 1741622496133 - 1741622496123 = 10 мс

// --- Выводим результат измерения ---
// Используем шаблонную строку для вывода результата.
console.log(`Прошло времени: ${elapsedTime} мс`); // Например: "Прошло времени: 10 мс"
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (примерно):</p>
                <pre><code class="language-text">Начало выполнения цикла...
   Выполнение итерации: 0
   Выполнение итерации: 1
   ...
   Выполнение итерации: 100
Конец выполнения цикла.
Прошло времени: 10 мс</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>startTime = Date.now()</code> — фиксирует время начала.</li>
                    <li><code>for (let i = 0; i <= 100; i += 1)</code> — цикл, который выполняется 101 раз.</li>
                    <li><code>endTime = Date.now()</code> — фиксирует время окончания.</li>
                    <li><code>elapsedTime = endTime - startTime</code> — вычисляет, сколько миллисекунд прошло.</li>
                    <li><code>console.log(`Прошло времени: ${elapsedTime} мс`)</code> — выводит результат, используя
                        шаблонный литерал.</li>
                </ul>
                <p>Ответ на вопрос: <strong>Что возвращает метод <code>Date.now()</code>?</strong></p>
                <pre><code class="language-text">Ответ: Число (количество миллисекунд с 1 января 1970 года).</code></pre>
            </section>

            <section class="scroll-reveal">
                <h3>Геттеры и сеттеры для компонентов даты</h3>
                <p>Объект <code>Date</code> имеет множество методов для чтения (геттеры) и изменения (сеттеры) значений
                    даты
                    и времени. Эти методы позволяют работать с годом, месяцем, днём, часами, минутами, секундами и
                    миллисекундами.</p>
                <p><strong>Важно:</strong> Значения, возвращаемые геттерами и устанавливаемые сеттерами, зависят от
                    **локального часового пояса**, установленного на компьютере пользователя.</p>

                <h4>Геттеры</h4>
                <p>Геттеры возвращают части даты или времени.</p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Геттеры для Date =====
// Создаём объект Date с конкретной датой и временем.
const date = new Date("March 16, 2030 14:25:00"); // Дата: 16 марта 2030, Время: 14:25:00

// Выводим объект Date, чтобы видеть его полное строковое представление с часовым поясом.
console.log("Дата: ", date); // Например: "Sat Mar 16 2030 14:25:00 GMT+0200"

// --- Используем геттеры для чтения компонентов даты и времени ---

// getFullYear(): Возвращает полный год (4 цифры).
console.log("Полный год: ", date.getFullYear()); // 2030

// getMonth(): Возвращает номер месяца (0-11). 0 - январь, 2 - март, 11 - декабрь.
console.log("Месяц (0-11): ", date.getMonth()); // 2 (т.к. март)

// getDate(): Возвращает день месяца (1-31).
console.log("День месяца (1-31): ", date.getDate()); // 16

// getDay(): Возвращает день недели (0-6). 0 - воскресенье, 6 - суббота.
console.log("День недели (0-6, 0=Вс): ", date.getDay()); // 6 (т.к. суббота)

// getHours(): Возвращает часы (0-23).
console.log("Часы (0-23): ", date.getHours()); // 14

// getMinutes(): Возвращает минуты (0-59).
console.log("Минуты (0-59): ", date.getMinutes()); // 25

// getSeconds(): Возвращает секунды (0-59).
console.log("Секунды (0-59): ", date.getSeconds()); // 0

// getMilliseconds(): Возвращает миллисекунды (0-999).
console.log("Миллисекунды (0-999): ", date.getMilliseconds()); // 0

// getTimstamp / getTime(): Возвращает Unix-время (мс с 1970 UTC).
console.log("Unix-время (мс):", date.getTime()); // Например: 1899923100000

// getDay() для 1 января 1970 UTC (timestamp 0)
console.log("День недели для 1970-01-01 (0=Чт):", new Date(0).getDay()); // 4 (четверг)
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Дата:  Sat Mar 16 2030 14:25:00 GMT+0200
Полный год:  2030
Месяц (0-11):  2
День месяца (1-31):  16
День недели (0-6, 0=Вс):  6
Часы (0-23):  14
Минуты (0-59):  25
Секунды (0-59):  0
Миллисекунды (0-999):  0
Unix-время (мс): 1899923100000
День недели для 1970-01-01 (0=Чт): 4</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>new Date("March 16, 2030 14:25:00")</code> — создаёт объект с датой 16 марта 2030 года,
                        14:25:00.</li>
                    <li><code>date.getDate()</code> — возвращает день месяца (16).</li>
                    <li><code>date.getDay()</code> — возвращает день недели (6, суббота, так как 0 — это воскресенье).
                    </li>
                    <li><code>date.getMonth()</code> — возвращает месяц (2, март, так как месяцы начинаются с 0).</li>
                    <li><code>date.getFullYear()</code> — возвращает полный год (2030).</li>
                    <li><code>date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()</code> —
                        возвращают часы, минуты, секунды и миллисекунды соответственно.</li>
                </ul>

                <h4>Сеттеры</h4>
                <p>Сеттеры позволяют изменять компоненты даты. Они начинаются с префикса <code>set</code>.</p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Сеттеры для Date =====
// Создаём объект Date с начальной датой и временем.
const date = new Date("March 16, 2030 14:25:00"); // Sat Mar 16 2030 14:25:00 GMT+0200

// Выводим исходную дату.
console.log("Исходная дата: ", date);

// --- Используем сеттеры для изменения компонентов ---

// setMinutes(minutes): Изменяет минуты.
date.setMinutes(50); // Теперь время 14:50:00.
console.log("После setMinutes(50):", date); // Например: "Sat Mar 16 2030 14:50:00 GMT+0200"

// setFullYear(year): Изменяет полный год.
date.setFullYear(2040); // Теперь год 2040.
console.log("После setFullYear(2040):", date); // Например: "Fri Mar 16 2040 14:50:00 GMT+0200"

// setMonth(month): Изменяет месяц (0-11).
date.setMonth(4); // Устанавливаем месяц 4 (т.е. май).
console.log("После setMonth(4) [Май]:", date); // Например: "Wed May 16 2040 14:50:00 GMT+0300"
// Обратите внимание: изменение месяца может повлиять на часовой пояс из-за перехода на летнее/зимнее время.

// setDate(day): Изменяет день месяца (1-31).
date.setDate(1); // Устанавливаем 1-е число месяца.
console.log("После setDate(1):", date); // Например: "Mon May 01 2040 14:50:00 GMT+0300"

// setHours(hours): Изменяет часы (0-23).
date.setHours(9); // Устанавливаем 9 утра.
console.log("После setHours(9):", date); // Например: "Mon May 01 2040 09:50:00 GMT+0300"

// setSeconds(seconds): Изменяет секунды (0-59).
date.setSeconds(30); // Устанавливаем 30 секунд.
console.log("После setSeconds(30):", date); // Например: "Mon May 01 2040 09:50:30 GMT+0300"

// setMilliseconds(ms): Изменяет миллисекунды (0-999).
date.setMilliseconds(500); // Устанавливаем 500 миллисекунд.
console.log("После setMilliseconds(500):", date); // Например: "Mon May 01 2040 09:50:30 GMT+0300" (вывод может не показывать мс)

// setTime(timestamp): Устанавливает дату и время с помощью Unix-времени (миллисекунд с 1970).
date.setTime(0); // Устанавливаем на начало Unix-эпохи.
console.log("После setTime(0):", date); // Например: "Thu Jan 01 1970 03:00:00 GMT+0300"
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Исходная дата:  Sat Mar 16 2030 14:25:00 GMT+0200
После setMinutes(50): Sat Mar 16 2030 14:50:00 GMT+0200
После setFullYear(2040): Fri Mar 16 2040 14:50:00 GMT+0200
После setMonth(4) [Май]: Wed May 16 2040 14:50:00 GMT+0300
После setDate(1): Mon May 01 2040 14:50:00 GMT+0300
После setHours(9): Mon May 01 2040 09:50:00 GMT+0300
После setSeconds(30): Mon May 01 2040 09:50:30 GMT+0300
После setMilliseconds(500): Mon May 01 2040 09:50:30 GMT+0300
После setTime(0): Thu Jan 01 1970 03:00:00 GMT+0300</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>date.setMinutes(50)</code> — изменяет минуты на 50, оставляя остальные компоненты без
                        изменений.</li>
                    <li><code>date.setFullYear(2040)</code> — изменяет год на 2040.</li>
                    <li><code>date.setMonth(4)</code> — изменяет месяц на май (4). Обратите внимание, что часовой пояс
                        может
                        измениться (например, с GMT+0200 на GMT+0300), так как в мае может действовать летнее время.
                    </li>
                    <li>Каждый вызов сеттера изменяет объект <code>Date</code>, и результат сразу отражается в объекте.
                    </li>
                    <li><code>date.setTime(timestamp)</code> — удобный способ установить всю дату и время, используя
                        числовое Unix-время.</li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h4>Практическое задание с Date, setInterval и setTimeout</h4>
                <p>Давай напишем код, который:</p>
                <ul>
                    <li>Каждые 2 секунды выводит текущее время в формате ЧЧ:ММ:СС.</li>
                    <li>Через 10 секунд останавливает этот интервал.</li>
                </ul>
                <p>Решение:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Практическое задание: Вывод времени с остановкой =====
// Этот код использует setInterval и setTimeout для периодического вывода времени.

// --- Функция, которая будет вызываться интервалом ---
// Определяем стрелочную функцию 'showTime'.
const showTime = () => {
  // 1. Создаём объект с текущей датой и временем в момент вызова этой функции.
  const now = new Date(); // Например: Date { ... текущее время ... }

  // 2. Получаем компоненты времени (часы, минуты, секунды) из объекта 'now' с помощью геттеров.
  const hours = now.getHours();     // Часы (0–23, в локальном поясе)
  const minutes = now.getMinutes();   // Минуты (0–59, в локальном поясе)
  const seconds = now.getSeconds();   // Секунды (0–59, в локальном поясе)

  // 3. Формируем строку времени в нужном формате "ЧЧ:ММ:СС".
  // Используем шаблонный литерал (`).
  // Опционально: можно добавить ведущий ноль для чисел меньше 10, например:
  // const formattedHours = String(hours).padStart(2, '0'); // "9" -> "09"
  // const formattedMinutes = String(minutes).padStart(2, '0');
  // const formattedSeconds = String(seconds).padStart(2, '0');
  // const timeString = `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
  const timeString = `${hours}:${minutes}:${seconds}`; // Простой формат без ведущих нулей

  // 4. Выводим сформированную строку времени в консоль.
  console.log(timeString);
};

// --- Запуск интервала ---
// Используем setInterval() для вызова функции 'showTime' повторно через равные промежутки времени.
// Первый аргумент - функция, которую нужно вызывать (showTime).
// Второй аргумент - задержка между вызовами в миллисекундах (2000 мс = 2 секунды).
// setInterval возвращает числовой идентификатор, который мы сохраняем, чтобы потом остановить интервал.
const intervalId = setInterval(showTime, 2000); // Интервал запущен!

// Выводим сообщение о запуске интервала и его ID.
console.log("Интервал запущен, вывод времени каждые 2 секунды. ID:", intervalId);

// --- Остановка интервала через задержку ---
// Используем setTimeout() для планирования ОДНОГО вызова функции через 10 секунд.
// Эта функция остановит наш интервал.
setTimeout(() => { // Первый аргумент setTimeout - функция, которую нужно выполнить.
  // --- Код внутри функции setTimeout ---
  // 1. Остановка интервала: вызываем clearInterval(), передавая ID интервала, который нужно остановить.
  clearInterval(intervalId); // Используем ID интервала, полученный ранее.
  // 2. Выводим сообщение о том, что интервал остановлен.
  console.log("Вывод времени остановлен после 10 секунд.");
  // Конец кода внутри setTimeout.
}, 10000); // Второй аргумент setTimeout - задержка (10000 мс = 10 секунд).

// Основной код здесь завершен. Дальнейшее выполнение происходит по таймерам.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (примерно):</p>
                <pre><code class="language-text">Интервал запущен, вывод времени каждые 2 секунды. ID: [некое число]
14:30:00 // через ~2 секунды
14:30:02 // через ~4 секунды
14:30:04 // через ~6 секунды
14:30:06 // через ~8 секунды
14:30:08 // через ~10 секунды
Вывод времени остановлен после 10 секунд. // через ~10 секунд (почти одновременно с последним выводом времени)</code></pre>
            </section>
            <!-- Конец второго блока материала -->


            <!-- ============================================ -->
            <!-- Начало третьего блока материала: Промисы -->
            <!-- ============================================ -->
            <h2 id="async-promises">Что такое промисы?</h2>
            <section class="scroll-reveal">
                <h3>Аналогия и Определение</h3>
                <p><strong>Аналогия:</strong><br>Представь, что Полина обещает испечь торт на твой день рождения через
                    две
                    недели. Возможны два исхода:</p>
                <ul>
                    <li>Если всё будет хорошо, ты получишь торт (Успех).</li>
                    <li>Если Полина заболеет, торта не будет, но вечеринка всё равно состоится (Ошибка).</li>
                </ul>
                <p>Обещание — это не гарантия, а лишь надежда на результат в будущем. В программировании промисы
                    работают
                    похожим образом.</p>

                <p><strong>Определение:</strong><br>
                    <strong>Промис (от англ. promise — обещание)</strong> — это объект, который представляет текущее
                    состояние асинхронной операции. Он как обёртка для значения, которое станет известно только позже.
                    Промисы позволяют обрабатывать результаты асинхронных операций (например, запросов к серверу) так,
                    будто
                    они синхронные: вместо немедленного результата ты получаешь "обещание" получить его позже.
                </p>
                <p>Пример реальной асинхронной операции, где используются промисы:<br>
                    Запрос данных с сервера: ты отправляешь запрос, но ответ придёт через несколько секунд. Промис
                    позволяет
                    "ждать" ответа, не блокируя программу.</p>
                <p>Ответ на вопрос: <strong>Что такое промис?</strong></p>
                <pre><code class="language-text">Ответ: Объект, который хранит состояние асинхронной операции.</code></pre>
            </section>

            <section class="scroll-reveal">
                <h3>Жизненный цикл промиса</h3>
                <p>Промис может находиться в трёх состояниях:</p>
                <ul>
                    <li><strong>Ожидание (pending)</strong> — начальное состояние, когда промис только создан и операция
                        ещё
                        не завершена.</li>
                    <li><strong>Выполнен (fulfilled)</strong> — операция завершена успешно, и промис возвращает
                        результат
                        (значение).</li>
                    <li><strong>Отклонён (rejected)</strong> — операция завершена с ошибкой, и промис возвращает причину
                        ошибки.</li>
                </ul>
                <p><strong>Важно:</strong></p>
                <ul>
                    <li>Промис всегда начинается в состоянии pending.</li>
                    <li>Из pending он может перейти либо в fulfilled, либо в rejected — это необратимо (промис нельзя
                        изменить после завершения).</li>
                    <li>Когда промис переходит в fulfilled или rejected, он считается <strong>завершённым
                            (settled)</strong>. Settled — это не отдельное состояние, а просто термин, означающий, что
                        промис больше не в ожидании.</li>
                </ul>
                <p>Пример аналогии:</p>
                <ul>
                    <li>Полина готовит торт (pending).</li>
                    <li>Если торт готов, ты его получаешь (fulfilled).</li>
                    <li>Если она заболела, торт не готов (rejected).</li>
                    <li>В любом случае процесс завершён (settled).</li>
                </ul>
                <p>Ответы на вопросы:</p>
                <ul>
                    <li><strong>Какие состояния существуют у промиса?</strong><br>
                        <pre><code class="language-text">Ответ: Pending, Fulfilled, Rejected.</code></pre>
                    </li>
                    <li><strong>В каком состоянии изначально находится промис?</strong><br>
                        <pre><code class="language-text">Ответ: Pending.</code></pre>
                    </li>
                    <li><strong>В какое состояние переходит успешно выполненный промис?</strong><br>
                        <pre><code class="language-text">Ответ: Fulfilled.</code></pre>
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Создание промиса</h3>
                <p>Промис создаётся как экземпляр класса <code>Promise</code>. Конструктор <code>Promise</code>
                    принимает
                    исполнительную функцию (executor), которая выполняется сразу же при создании промиса.</p>
                <p>Синтаксис:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// Синтаксис создания нового Промиса
const promise = new Promise((resolve, reject) => { // new Promise() вызывает конструктор класса Promise.
  // В конструктор передаётся ОДНА функция - исполнительная функция (executor).
  // Эта функция выполняется СРАЗУ при создании промиса.
  // Исполнительная функция принимает два аргумента:
  // resolve - функция, которую нужно вызвать при УСПЕХЕ.
  // reject - функция, которую нужно вызвать при ОШИБКЕ.

  // --- Асинхронная операция (например, запрос к серверу, таймер) ---
  // Здесь помещается код, который выполняет асинхронную задачу.
  // В зависимости от результата задачи (успех/ошибка), вызывается resolve или reject.

  // Пример с имитацией задержки таймером:
  // setTimeout(() => {
  //   // После задержки...
  //   if (успех) {
  //     resolve(результат_успеха); // Вызываем resolve с результатом
  //   } else {
  //     reject(причина_ошибки); // Вызываем reject с ошибкой
  //   }
  // }, время_задержки);
}); // Конец создания промиса.
</code></pre>
                    <div class="button-group">
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p><strong>Объяснение параметров исполнительной функции:</strong></p>
                <ul>
                    <li><code>resolve(value)</code> — функция, которая вызывается, если операция успешна. Она переводит
                        промис в состояние <code>fulfilled</code> и передаёт результат (<code>value</code>).</li>
                    <li><code>reject(error)</code> — функция, которая вызывается, если операция завершилась с ошибкой.
                        Она
                        переводит промис в состояние <code>rejected</code> и передаёт причину ошибки
                        (<code>error</code>).
                    </li>
                </ul>
                <p>Исполнительная функция (<code>(resolve, reject) => {...}</code>) — это код, который выполняет
                    асинхронную
                    операцию (например, запрос к серверу или таймер).</p>

                <p>Пример создания и вывода промиса (он будет в состоянии 'pending' на момент вывода):</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Пример создания промиса (Pending) =====
// Переменная для имитации успеха или ошибки операции, которая будет внутри промиса.
const isSuccess = true; // Измените на 'false', чтобы увидеть, что произойдёт при ошибке.

// Создаём новый Промис.
const promise = new Promise((resolve, reject) => { // new Promise() вызывает конструктор. Передаём executor.
  // --- Исполнительная функция (executor) ---
  // Эта функция выполняется СРАЗУ при создании промиса.
  // Внутри имитируем асинхронную операцию с задержкой.
  setTimeout(() => { // setTimeout() - имитация асинхронности. Этот код внутри выполнится через 2 секунды.
    // Этот код выполняется после задержки.
    // Проверяем условие успеха (иммитация результата асинхронной операции).
    if (isSuccess) {
      // Если isSuccess === true, операция считается успешной.
      // Вызываем функцию resolve() с результатом. Это переведёт промис в состояние fulfilled.
      resolve("Успех! Значение передано в resolve"); // Передаем строку как результат.
    } else {
      // Если isSuccess === false, операция считается завершившейся с ошибкой.
      // Вызываем функцию reject() с причиной ошибки. Это переведёт промис в состояние rejected.
      reject("Ошибка! Ошибка передана в reject"); // Передаем строку как причина ошибки.
    }
  }, 2000); // 2000 миллисекунд = 2 секунды - задержка перед вызовом resolve или reject.
}); // Конец создания промиса.

// Выводим объект промиса в консоль СРАЗУ после его создания.
// На этот момент асинхронная операция (setTimeout) ещё не завершилась (прошло 0 секунд),
// поэтому промис находится в состоянии ОЖИДАНИЯ (pending).
console.log("Промис создан. Текущее состояние:", promise); // Выводит "Промис создан. Текущее состояние: Promise { <pending> }"
// Через 2 секунды состояние промиса изменится на fulfilled или rejected (это будет видно в консоли браузера).
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат через 2 секунды:</p>
                <p>Если <code>isSuccess = true</code>, промис перейдёт в <code>fulfilled</code> с результатом "Успех!
                    Значение передано в resolve".<br>
                    Если <code>isSuccess = false</code>, промис перейдёт в <code>rejected</code> с ошибкой "Ошибка!
                    Ошибка
                    передана в reject".</p>
                <p>Ответы на вопросы:</p>
                <ul>
                    <li><strong>Какой правильный синтаксис создания промиса?</strong><br>
                        <pre><code class="language-text">Ответ: const promise = new Promise(executor).</code></pre>
                    </li>
                    <li><strong>Что возвращает вызов <code>new Promise()</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Объект (экземпляр класса Promise).</code></pre>
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Метод then()</h3>
                <p>Метод <code>then()</code> используется для обработки результата промиса. Он вызывается, когда промис
                    переходит из состояния <code>pending</code> в <code>fulfilled</code> или <code>rejected</code>.</p>
                <p>Синтаксис:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// Синтаксис метода .then()
promise.then(onResolve, onReject); // then() принимает два необязательных аргумента - функции-колбэки.</code></pre>
                    <div class="button-group">
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <ul>
                    <li><code>onResolve(value)</code> — колбэк-функция, которая вызывается, если промис успешно выполнен
                        (<code>fulfilled</code>). Она получает результат промиса (<code>value</code>) в качестве
                        аргумента.
                    </li>
                    <li><code>onReject(error)</code> — колбэк-функция, которая вызывается, если промис отклонён
                        (<code>rejected</code>). Она получает ошибку (<code>error</code>) в качестве аргумента.</li>
                </ul>
                <p><code>onReject</code> необязателен, так как ошибки часто обрабатываются отдельно с помощью
                    <code>catch()</code>.
                </p>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Пример использования метода .then() =====
// Переменная для имитации успеха операции, которая будет внутри промиса.
const isSuccess = true; // Измените на 'false', чтобы увидеть, как сработает второй колбэк.

// Создаём новый Промис.
const promise = new Promise((resolve, reject) => { // Создаем промис с executor.
  // Имитация асинхронной операции с задержкой 2 секунды.
  setTimeout(() => {
    if (isSuccess) {
      // Если успех, вызываем resolve с результатом.
      resolve("Успех! Значение передано в resolve");
    } else {
      // Если ошибка, вызываем reject с причиной.
      reject("Ошибка! Ошибка передана в reject");
    }
  }, 2000); // Задержка 2 секунды.
}); // Конец создания промиса.

// Выводим сообщение в консоль, что начинаем обрабатывать промис.
console.log("Начинаем обрабатывать промис методом .then()...");

// --- Используем метод .then() для обработки результата промиса ---
// Метод .then() вызывается у объекта промиса. Он регистрирует функции-обработчики.
promise.then( // Регистрируем обработчики для промиса.
  (value) => { // --- Первый колбэк: onResolve ---
    // Этот колбэк вызывается ТОЛЬКО ЕСЛИ промис переходит в состояние fulfilled.
    // 'value' - это аргумент, который был передан в функцию resolve().
    console.log("Результат успешного выполнения (onResolve):", value); // Если isSuccess=true, выведет "Успех!..."
  },
  (error) => { // --- Второй колбэк: onReject ---
    // Этот колбэк вызывается ТОЛЬКО ЕСЛИ промис переходит в состояние rejected.
    // 'error' - это аргумент, который был передан в функцию reject().
    console.log("Результат ошибки (onReject):", error); // Если isSuccess=false, выведет "Ошибка!..."
  }
); // Конец вызова .then().
// Код здесь выполняется СРАЗУ после регистрации обработчиков, не ждя их срабатывания.
console.log("Метод .then() зарегистрировал обработчики и завершил синхронное выполнение.");
// Срабатывание колбэков then() произойдет асинхронно, после завершения setTimeout.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (если <code>isSuccess = true</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then()...
Метод .then() зарегистрировал обработчики и завершил синхронное выполнение.
Результат успешного выполнения (onResolve): Успех! Значение передано в resolve // Через ~2 секунды</code></pre>
                <p>Результат в консоли (если <code>isSuccess = false</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then()...
Метод .then() зарегистрировал обработчики и завершил синхронное выполнение.
Результат ошибки (onReject): Ошибка! Ошибка передана в reject // Через ~2 секунды</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>promise.then((value) => {...}, (error) => {...})</code> — регистрирует два колбэка:</li>
                    <li>Первый колбэк (<code>(value) => {...}</code>) — стрелочная функция, которая вызывается, если
                        промис
                        <code>fulfilled</code>. Она получает результат (<code>value</code>) и выводит его в консоль.
                    </li>
                    <li>Второй колбэк (<code>(error) => {...}</code>) — стрелочная функция, которая вызывается, если
                        промис
                        <code>rejected</code>. Она получает ошибку (<code>error</code>) и выводит её в консоль.
                    </li>
                    <li>Если <code>isSuccess = true</code>, через 2 секунды вызывается первый колбэк и выводится
                        "Успех!...".</li>
                    <li>Если <code>isSuccess = false</code>, вызывается второй колбэк и выводится "Ошибка!...".</li>
                </ul>

                <p>Пример с внешними функциями:</p>
                <p>Если логика обработки результата или ошибки сложная, колбэки можно вынести в отдельные именованные
                    функции. Это делает код чище и понятнее.</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Пример .then() с внешними функциями =====
// Переменная для имитации успеха операции.
const isSuccess = true; // Измените на 'false', чтобы сработал обработчик ошибки.

// --- Внешние функции для обработки результата и ошибки ---
// Функция для обработки успешного выполнения промиса.
const handleSuccess = (value) => {
  console.log("Обработчик успеха сработал:", value); // Выводит полученное значение.
};

// Функция для обработки ошибки промиса.
const handleError = (error) => {
  console.log("Обработчик ошибки сработал:", error); // Выводит полученную ошибку.
};

// --- Создаём промис ---
const promise = new Promise((resolve, reject) => { // Создаем промис.
  // Имитация асинхронной операции.
  setTimeout(() => {
    if (isSuccess) {
      resolve("Успех! Значение передано в resolve"); // Успех после 2 секунд.
    } else {
      reject("Ошибка! Ошибка передана в reject"); // Ошибка после 2 секунд.
    }
  }, 2000); // Задержка.
}); // Конец создания промиса.

// Выводим сообщение в консоль.
console.log("Начинаем обрабатывать промис методом .then() с внешними функциями...");

// --- Используем метод .then() и передаем в него ссылки на ВНЕШНИЕ функции ---
// Вместо анонимных инлайн-функций, передаем ссылки на handleSuccess и handleError.
promise.then(handleSuccess, handleError);

console.log("Метод .then() зарегистрировал внешние обработчики и завершил синхронное выполнение.");
// Внешние функции handleSuccess или handleError сработают асинхронно после завершения setTimeout.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (если <code>isSuccess = true</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then() с внешними функциями...
Метод .then() зарегистрировал внешние обработчики и завершил синхронное выполнение.
Обработчик успеха сработал: Успех! Значение передано в resolve // Через ~2 секунды</code></pre>
                <p>Результат в консоли (если <code>isSuccess = false</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then() с внешними функциями...
Метод .then() зарегистрировал внешние обработчики и завершил синхронное выполнение.
Обработчик ошибки сработал: Ошибка! Ошибка передана в reject // Через ~2 секунды</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>handleSuccess</code> и <code>handleError</code> — именованные стрелочные функции, которые
                        обрабатывают успех и ошибку.</li>
                    <li><code>promise.then(handleSuccess, handleError)</code> — передаёт эти функции в
                        <code>then</code>,
                        что делает код чище и понятнее.
                    </li>
                </ul>
                <p>Ответы на вопросы:</p>
                <ul>
                    <li><strong>Какой метод промиса используется для обработки его результата?</strong><br>
                        <pre><code class="language-text">Ответ: then.</code></pre>
                    </li>
                    <li><strong>Когда выполняется колбэк-функция, переданная первым аргументом в
                            <code>then</code>?</strong><br>
                        <pre><code class="language-text">Ответ: После того, как промис выполнен успешно (fulfilled).</code></pre>
                    </li>
                    <li><strong>Что получает функция, переданная первым аргументом в <code>then</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Значение, с которым выполнен промис.</code></pre>
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Метод catch()</h3>
                <p>Метод <code>catch()</code> используется для обработки ошибок, если промис завершается в состоянии
                    <code>rejected</code>. Обычно ошибки обрабатывают отдельно от успешных результатов с помощью
                    <code>catch()</code>, а успешные результаты с помощью <code>then()</code> с одним аргументом (только
                    <code>onResolve</code>). Этот подход делает код более читаемым.
                </p>
                <p>Синтаксис:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// Синтаксис .then().catch()
promise
  .then(value => { // Колбэк для УСПЕХА (fulfilled). Получает value.
    // Обработка успешного результата
  })
  .catch(error => { // Колбэк для ОШИБКИ (rejected). Получает error.
    // Обработка ошибки
  });
// Этот синтаксис эквивалентен promise.then(null, error => { ... });
// catch(onReject) - это просто более удобный способ записи .then(null, onReject).
</code></pre>
                    <div class="button-group">
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Пример использования метода .catch() =====
// Переменная для имитации успеха операции.
const isSuccess = false; // Измените на 'true', чтобы сработал .then().

// Создаём промис.
const promise = new Promise((resolve, reject) => { // Создаем промис с executor.
  // Имитация асинхронной операции с задержкой 2 секунды.
  setTimeout(() => {
    if (isSuccess) {
      // Если успех, вызываем resolve.
      resolve("Успех! Значение передано в resolve");
    } else {
      // Если ошибка, вызываем reject.
      reject("Ошибка! Ошибка передана в reject"); // Эта ветка сработает, т.к. isSuccess=false.
    }
  }, 2000); // Задержка 2 секунды.
}); // Конец создания промиса.

// Выводим сообщение.
console.log("Начинаем обрабатывать промис методом .then().catch()...");

// --- Используем .then() и .catch() ---
promise
  .then((value) => { // Первый then() с колбэком только для успешного выполнения.
    // Этот колбэк вызывается ТОЛЬКО ЕСЛИ промис fulfilled.
    // Получает значение (value), переданное в resolve().
    console.log("Результат успешного выполнения (.then()):", value); // Выведется, если isSuccess=true.
  })
  .catch((error) => { // Метод .catch() с колбэком только для ошибок.
    // Этот колбэк вызывается ТОЛЬКО ЕСЛИ промис rejected.
    // Получает ошибку (error), переданную в reject().
    console.log("Результат ошибки (.catch()):", error); // Выведется, если isSuccess=false.
  }); // Конец цепочки then().catch().
// Код здесь выполняется СРАЗУ.
console.log("Методы .then().catch() зарегистрировали обработчики и завершили синхронное выполнение.");
// Срабатывание колбэков произойдет асинхронно после setTimeout.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (если <code>isSuccess = true</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then().catch()...
Методы .then().catch() зарегистрировали обработчики и завершили синхронное выполнение.
Результат успешного выполнения (.then()): Успех! Значение передано в resolve // Через ~2 секунды</code></pre>
                <p>Результат в консоли (если <code>isSuccess = false</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then().catch()...
Методы .then().catch() зарегистрировали обработчики и завершили синхронное выполнение.
Результат ошибки (.catch()): Ошибка! Ошибка передана в reject // Через ~2 секунды</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>promise.then((value) => {...})</code> — обрабатывает успешное выполнение
                        (<code>fulfilled</code>). Если промис <code>rejected</code>, этот колбэк не вызывается.</li>
                    <li><code>promise.catch((error) => {...})</code> — обрабатывает ошибку (<code>rejected</code>).
                        Вызывается, если <code>isSuccess = false</code>, и выводит ошибку.</li>
                    <li><code>catch</code> обычно ставится после <code>then</code>, чтобы перехватывать ошибки,
                        возникшие в
                        промисе или в цепочке <code>then</code>.</li>
                </ul>
                <p>Ответы на вопросы:</p>
                <ul>
                    <li><strong>Выполнится ли метод <code>catch</code>, если промис выполнен без ошибки?</strong><br>
                        <pre><code class="language-text">Ответ: Нет.</code></pre>
                    </li>
                    <li><strong>Когда выполняется функция, переданная в <code>catch</code>?</strong><br>
                        <pre><code class="language-text">Ответ: После того, как промис выполнен с ошибкой (rejected).</code></pre>
                    </li>
                    <li><strong>Что получает функция, переданная в <code>catch</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Ошибку, с которой выполнен промис.</code></pre>
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Метод finally()</h3>
                <p>Метод <code>finally()</code> вызывается в любом случае, независимо от того, завершился промис успешно
                    (<code>fulfilled</code>) или с ошибкой (<code>rejected</code>). Он полезен для выполнения кода,
                    который
                    должен быть выполнен всегда, например, для очистки или логирования.</p>
                <p>Синтаксис:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// Синтаксис .then().catch().finally()
promise
  .then(value => { // Колбэк для успеха
    // Обработка успеха
  })
  .catch(error => { // Колбэк для ошибки
    // Обработка ошибки
  })
  .finally(() => { // Колбэк для завершения (без аргументов)
    // Этот колбэк выполняется ВСЕГДА, независимо от результата (fulfilled или rejected).
    // Здесь можно выполнить код, который должен сработать после асинхронной операции в любом случае.
  });
// finally() возвращает новый промис, который завершается с тем же результатом (успех или ошибка) и значением,
// с которым завершился промис до finally().
</code></pre>
                    <div class="button-group">
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Пример использования метода .finally() =====
// Переменная для имитации успеха операции.
const isSuccess = true; // Измените на 'false', чтобы увидеть, как сработает catch перед finally.

// Создаём промис.
const promise = new Promise((resolve, reject) => { // Создаем промис с executor.
  // Имитация асинхронной операции с задержкой 2 секунды.
  setTimeout(() => {
    if (isSuccess) {
      // Если успех, вызываем resolve.
      resolve("Успех! Значение передано в resolve"); // Сработает, если isSuccess=true.
    } else {
      // Если ошибка, вызываем reject.
      reject("Ошибка! Ошибка передана в reject"); // Сработает, если isSuccess=false.
    }
  }, 2000); // Задержка 2 секунды.
}); // Конец создания промиса.

// Выводим сообщение.
console.log("Начинаем обрабатывать промис методом .then().catch().finally()...");

// --- Используем .then(), .catch() и .finally() ---
promise
  .then((value) => { // Колбэк для успешного выполнения.
    console.log("Результат успешного выполнения (.then()):", value); // Выведется, если промис fulfilled.
  })
  .catch((error) => { // Колбэк для ошибки.
    console.log("Результат ошибки (.catch()):", error); // Выведется, если промис rejected.
  })
  .finally(() => { // Колбэк для завершения.
    // Этот колбэк выполняется ВСЕГДА, независимо от того, был промис выполнен успешно или с ошибкой.
    // Внутри finally() НЕТ информации о результате или ошибке (колбэк не принимает аргументов).
    console.log("Промис завершён (finally сработал)"); // Выведется в любом случае.
  }); // Конец цепочки.
// Код здесь выполняется СРАЗУ.
console.log("Методы .then().catch().finally() зарегистрировали обработчики и завершили синхронное выполнение.");
// Срабатывание колбэков произойдет асинхронно после setTimeout.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (если <code>isSuccess = true</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then().catch().finally()...
Методы .then().catch().finally() зарегистрировали обработчики и завершили синхронное выполнение.
Результат успешного выполнения (.then()): Успех! Значение передано в resolve // Через ~2 секунды
Промис завершён (finally сработал) // Сразу после then</code></pre>
                <p>Результат (если <code>isSuccess = false</code>):</p>
                <pre><code class="language-text">Начинаем обрабатывать промис методом .then().catch().finally()...
Методы .then().catch().finally() зарегистрировали обработчики и завершили синхронное выполнение.
Результат ошибки (.catch()): Ошибка! Ошибка передана в reject // Через ~2 секунды
Промис завершён (finally сработал) // Сразу после catch</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>promise.then(...)</code> — вызывается, если промис <code>fulfilled</code>, и выводит
                        результат.</li>
                    <li><code>promise.catch(...)</code> — вызывается, если промис <code>rejected</code>, и выводит
                        ошибку.
                    </li>
                    <li><code>promise.finally(...)</code> — вызывается **в любом случае** (<code>fulfilled</code> или
                        <code>rejected</code>) и выводит сообщение.
                    </li>
                    <li>Колбэк в <code>finally</code> не получает аргументов, так как он не знает, был ли промис успешен
                        или
                        нет.</li>
                </ul>
                <p>Ответы на вопросы:</p>
                <ul>
                    <li><strong>Выполнится ли метод <code>finally</code>, если уже выполнился
                            <code>then</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Да.</code></pre>
                    </li>
                    <li><strong>Когда выполняется функция, переданная в <code>finally</code>?</strong><br>
                        <pre><code class="language-text">Ответ: После того, как промис выполнен успешно или с ошибкой.</code></pre>
                    </li>
                    <li><strong>Что получает функция, переданная в <code>finally</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Ничего (не получает аргументов).</code></pre>
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Цепочки промисов</h3>
                <p>Метод <code>then()</code> возвращает **новый промис**, который получает значение, возвращённое
                    колбэк-функцией <code>onResolve</code>. Это позволяет создавать **цепочки асинхронных операций**,
                    где
                    каждый <code>then</code> ждёт результата предыдущего.</p>
                <p>Особенности цепочек:</p>
                <ul>
                    <li>Каждый <code>then</code> возвращает новый промис, который зависит от результата колбэка,
                        выполненного внутри этого <code>then</code>.</li>
                    <li>Если в любом <code>then</code> или в исходном промисе возникает ошибка, выполнение переходит к
                        ближайшему <code>catch</code> в цепочке.</li>
                    <li><code>catch</code> обычно ставится в конце цепочки, чтобы перехватывать все ошибки, возникшие
                        ранее.
                    </li>
                    <li><code>finally</code> выполняется в конце, независимо от результата.</li>
                </ul>
                <p>Пример:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Пример цепочки промисов =====
// Создаём исходный Промис. Он имитирует операцию с задержкой 2 секунды и возвращает число 5.
const promise = new Promise((resolve, reject) => { // Создаем промис.
  // Имитация асинхронной операции с задержкой 2 секунды.
  setTimeout(() => {
    // Успех: вызываем resolve с числом 5. Промис переходит в fulfilled.
    resolve(5); // Промис завершится успешно со значением 5.
  }, 2000); // Задержка 2 секунды.
}); // Конец создания исходного промиса.

// Выводим сообщение.
console.log("Начинаем цепочку промисов...");

// --- Создаём ЦЕПОЧКУ промисов с помощью последовательных вызовов .then() ---
promise // Начинаем с исходного промиса.
  .then((value) => { // --- Первый .then() ---
    // Этот колбэк вызывается, когда ИСХОДНЫЙ промис завершается успешно.
    // 'value' здесь равно 5 (значение из resolve(5)).
    console.log("Первый then: Получено значение =", value); // Выводит "Первый then: Получено значение = 5".
    // Возвращаем НОВОЕ значение из этого колбэка. Это значение станет РЕЗУЛЬТАТОМ НОВОГО промиса,
    // который неявно возвращает этот .then().
    return value * 2; // Возвращаем 5 * 2 = 10. Этот .then() неявно вернет НОВЫЙ ПРОМИС со значением 10.
  })
  .then((value) => { // --- Второй .then() ---
    // Этот колбэк вызывается, когда ПРОМИС, возвращённый ПЕРВЫМ .then(), завершается успешно.
    // 'value' здесь равно 10 (значение, возвращенное из предыдущего колбэка).
    console.log("Второй then: Получено значение =", value); // Выводит "Второй then: Получено значение = 10".
    // Возвращаем НОВОЕ значение. Это значение станет РЕЗУЛЬТАТОМ СЛЕДУЮЩЕГО промиса.
    return value * 3; // Возвращаем 10 * 3 = 30. Этот .then() неявно вернет НОВЫЙ ПРОМИС со значением 30.
  })
  .then((value) => { // --- Третий .then() ---
    // Этот колбэк вызывается, когда ПРОМИС, возвращённый ВТОРЫМ .then(), завершается успешно.
    // 'value' здесь равно 30.
    console.log("Третий then: Получено значение =", value); // Выводит "Третий then: Получено значение = 30".
    // Если колбэк ничего не возвращает (как здесь) или возвращает undefined, то промис,
    // неявно возвращаемый этим .then(), завершится со значением undefined.
    // return undefined; // То же самое, что ничего не возвращать.
  })
  .catch((error) => { // --- .catch() ---
    // Этот блок вызывается, если ЛЮБОЙ из промисов в цепочке (исходный или любой из возвращенных .then())
    // завершается с ошибкой (rejected).
    console.error("Поймана ошибка в цепочке:", error); // Выведется, если где-то произошла ошибка.
  })
  .finally(() => { // --- .finally() ---
    // Этот блок вызывается ВСЕГДА, независимо от того, была ли в цепочке ошибка или нет.
    console.log("Цепочка промисов завершена (finally сработал)"); // Выведется после завершения цепочки.
  }); // Конец цепочки then().catch().finally().
// Код здесь выполняется СРАЗУ.
console.log("Цепочка промисов зарегистрирована и завершила синхронное выполнение.");
// Результаты then/catch/finally будут выведены асинхронно, по мере выполнения промисов.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">Начинаем цепочку промисов...
Цепочка промисов зарегистрирована и завершила синхронное выполнение.
Первый then: Получено значение = 5 // Через ~2 секунды
Второй then: Получено значение = 10 // Сразу после первого then
Третий then: Получено значение = 30 // Сразу после второго then
Цепочка промисов завершена (finally сработал) // Сразу после третьего then</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>resolve(5)</code> — исходный промис завершается успешно с результатом 5.</li>
                    <li>Первый <code>then</code>:
                        <ul>
                            <li>Получает <code>value = 5</code>, выводит его.</li>
                            <li>Возвращает <code>value * 2</code> (10), что становится результатом нового промиса.</li>
                        </ul>
                    </li>
                    <li>Второй <code>then</code>:
                        <ul>
                            <li>Получает <code>value = 10</code> (результат предыдущего), выводит его.</li>
                            <li>Возвращает <code>value * 3</code> (30).</li>
                        </ul>
                    </li>
                    <li>Третий <code>then</code>:
                        <ul>
                            <li>Получает <code>value = 30</code>, выводит его.</li>
                            <li>Ничего не возвращает (по умолчанию возвращается <code>undefined</code>), поэтому
                                следующий
                                промис (если бы он был) получил бы <code>undefined</code>.</li>
                        </ul>
                    </li>
                    <li><code>catch</code> — не вызывается, так как ошибок нет.</li>
                    <li><code>finally</code> — вызывается в конце и выводит сообщение.</li>
                </ul>
                <p>Ответы на вопросы:</p>
                <ul>
                    <li><strong>Что возвращает метод <code>then</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Промис.</code></pre>
                    </li>
                    <li><strong>Каким будет значение промиса, возвращённого из <code>then</code>?</strong><br>
                        <pre><code class="language-text">Ответ: Значение, которое возвращает его колбэк-функция.</code></pre>
                    </li>
                </ul>
            </section>

            <section class="scroll-reveal">
                <h3>Промисификация синхронных функций (с <code>Promise.resolve</code> / <code>Promise.reject</code>)
                </h3>
                <p>Методы <code>Promise.resolve()</code> и <code>Promise.reject()</code> удобны для промисификации
                    синхронных функций, когда нет асинхронной операции, но нужно вернуть промис для единообразия или
                    построения цепочек. Они создают промисы, которые немедленно переходят в состояние
                    <code>fulfilled</code>
                    или <code>rejected</code>.
                </p>

                <p>Исходная синхронная функция с колбэками:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Синхронная функция с колбэками =====
// Эта функция выполняется СИНХРОННО. Она не делает асинхронных операций.
// Она просто проверяет условие и СРАЗУ вызывает один из колбэков.
const makeGreeting = (guestName, onSuccess, onError) => { // Принимает имя и два колбэка.
  // Выводим сообщение.
  console.log(`[makeGreeting с колбэками] Попытка создать приветствие для "${guestName}"`);

  // Проверяем условие (например, есть ли имя).
  if (!guestName || guestName.trim() === "") { // Если имя пустое или состоит из пробелов.
    // Если условие ошибки истинно, СРАЗУ вызываем колбэк ошибки.
    console.log("   -> Имя пустое, вызываем onError.");
    onError("Username must not be empty"); // Вызываем переданный колбэк onError.
  } else {
    // Если условие успеха истинно, СРАЗУ вызываем колбэк успеха.
    console.log("   -> Имя есть, вызываем onSuccess.");
    onSuccess(`Welcome ${guestName}`); // Вызываем переданный колбэк onSuccess с результатом.
  }
  // Функция завершает выполнение СИНХРОННО.
};

// --- Вызов синхронной функции с колбэками ---
console.log("Вызов makeGreeting с колбэками (для 'Mango'):");
makeGreeting( // Вызываем функцию.
  "Mango", // Передаем имя.
  (greeting) => console.log("   onSuccess сработал:", greeting), // Инлайн колбэк для успеха.
  (error) => console.error("   onError сработал:", error) // Инлайн колбэк для ошибки.
);
console.log("Вызов makeGreeting с колбэками (для ''):");
makeGreeting( // Вызываем функцию снова.
  "", // Передаем пустое имя.
  (greeting) => console.log("   onSuccess сработал:", greeting),
  (error) => console.error("   onError сработал:", error) // Этот колбэк сработает.
);
// Весь этот код выполняется СИНХРОННО. Вывод в консоль будет немедленным.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">[makeGreeting с колбэками] Попытка создать приветствие для "Mango"
   -> Имя есть, вызываем onSuccess.
   onSuccess сработал: Welcome Mango
Вызов makeGreeting с колбэками (для ''):
[makeGreeting с колбэками] Попытка создать приветствие для ""
   -> Имя пустое, вызываем onError.
   onError сработал: Username must not be empty</code></pre>

                <p>Промисификация с использованием <code>new Promise()</code>:</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Промисифицированная синхронная функция (с new Promise) =====
// Преобразуем синхронную функцию makeGreeting, чтобы она возвращала промис.
const makeGreetingPromise = (guestName) => { // Теперь принимает только имя.
  console.log(`[makeGreetingPromise] Попытка создать приветствие для "${guestName}"`);
  // Возвращаем новый Промис.
  return new Promise((resolve, reject) => { // Создаем промис с executor.
    // Внутри executor помещаем СИНХРОННУЮ логику проверки имени.
    if (!guestName || guestName.trim() === "") {
      // Если ошибка, СРАЗУ вызываем reject.
      console.log("   -> Имя пустое, вызываем reject.");
      reject("Username must not be empty"); // Промис перейдет в rejected.
    } else {
      // Если успех, СРАЗУ вызываем resolve.
      console.log("   -> Имя есть, вызываем resolve.");
      resolve(`Welcome ${guestName}`); // Промис перейдет в fulfilled.
    }
    // Исполнительная функция executor завершается СИНХРОННО.
  }); // Промис создан и СРАЗУ переходит в fulfilled или rejected (т.к. нет асинхронных операций внутри executor).
};

// --- Вызов промисифицированной функции и обработка промиса ---
console.log("\nВызов makeGreetingPromise (для 'Mango'):");
makeGreetingPromise("Mango") // Вызываем функцию, получаем промис.
  .then((greeting) => console.log("   .then() сработал:", greeting)) // Обрабатываем успешный результат.
  .catch((error) => console.error("   .catch() сработал:", error)); // Обрабатываем ошибку.
// Промис для 'Mango' сразу становится fulfilled, и .then() сработает сразу (ну, почти, попадает в микроочередь промисов).

console.log("Вызов makeGreetingPromise (для ''):");
makeGreetingPromise("") // Вызываем функцию.
  .then((greeting) => console.log("   .then() сработал:", greeting))
  .catch((error) => console.error("   .catch() сработал:", error)); // .catch() сработает.
// Промис для '' сразу становится rejected, и .catch() сработает сразу (микроочередь).

console.log("Код после вызовов промисифицированной функции.");
// Вывод покажет, что этот код выполняется СРАЗУ после регистрации then/catch, не ждя их срабатывания.
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">[makeGreetingPromise] Попытка создать приветствие для "Mango"
   -> Имя есть, вызываем resolve.
Вызов makeGreetingPromise (для ''):
[makeGreetingPromise] Попытка создать приветствие для ""
   -> Имя пустое, вызываем reject.
Код после вызовов промисифицированной функции.
   .then() сработал: Welcome Mango // Срабатывает асинхронно (через микроочередь промисов)
   .catch() сработал: Username must not be empty // Срабатывает асинхронно (через микроочередь промисов)</code></pre>

                <p>Промисификация с использованием статических методов <code>Promise.resolve()</code> и
                    <code>Promise.reject()</code>:
                </p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== Промисифицированная синхронная функция (с Promise.resolve/reject) =====
// Самый короткий и чистый способ промисифицировать СИНХРОННУЮ функцию.
const makeGreetingStatic = (guestName) => { // Принимает только имя.
  console.log(`[makeGreetingStatic] Попытка создать приветствие для "${guestName}"`);
  // Проверяем условие.
  if (!guestName || guestName.trim() === "") {
    // Если ошибка, СРАЗУ возвращаем промис в состоянии rejected.
    console.log("   -> Имя пустое, возвращаем Promise.reject().");
    return Promise.reject("Guest name must not be empty"); // Создает и возвращает промис, который СРАЗУ rejected.
  }
  // Если успех, СРАЗУ возвращаем промис в состоянии fulfilled.
  console.log("   -> Имя есть, возвращаем Promise.resolve().");
  return Promise.resolve(`Welcome ${guestName}`); // Создает и возвращает промис, который СРАЗУ fulfilled.
};

// --- Вызов промисифицированной функции и обработка промиса ---
console.log("\nВызов makeGreetingStatic (для 'Mango'):");
makeGreetingStatic("Mango") // Вызываем функцию, получаем промис (сразу fulfilled).
  .then((greeting) => console.log("   .then() сработал:", greeting))
  .catch((error) => console.error("   .catch() сработал:", error));

console.log("Вызов makeGreetingStatic (для ''):");
makeGreetingStatic("") // Вызываем функцию, получаем промис (сразу rejected).
  .then((greeting) => console.log("   .then() сработал:", greeting))
  .catch((error) => console.error("   .catch() сработал:", error)); // Этот сработает.

console.log("Код после вызовов промисифицированной функции.");
// Вывод покажет, что этот код выполняется СРАЗУ, а then/catch срабатывают асинхронно (микроочередь).
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли:</p>
                <pre><code class="language-text">[makeGreetingStatic] Попытка создать приветствие для "Mango"
   -> Имя есть, возвращаем Promise.resolve().
Вызов makeGreetingStatic (для ''):
[makeGreetingStatic] Попытка создать приветствие для ""
   -> Имя пустое, возвращаем Promise.reject().
Код после вызовов промисифицированной функции.
   .then() сработал: Welcome Mango // Срабатывает асинхронно (микроочередь)
   .catch() сработал: Guest name must not be empty // Срабатывает асинхронно (микроочередь)</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li><code>Promise.reject("Guest name must not be empty")</code> — сразу возвращает промис в
                        состоянии
                        <code>rejected</code>.
                    </li>
                    <li><code>Promise.resolve(Welcome ${guestName})</code> — сразу возвращает промис в состоянии
                        <code>fulfilled</code>.
                    </li>
                    <li>Код короче и читаемее, чем с <code>new Promise</code>, когда нет реальной асинхронности.</li>
                </ul>
                <p>Результат в консоли (для "Mango"):</p>
                <pre><code class="language-text">Welcome Mango</code></pre>
                <p>Результат (для пустого имени ""):</p>
                <pre><code class="language-text">Guest name must not be empty</code></pre>
            </section>

            <section class="scroll-reveal">
                <h3>Создание промисов с задержкой (Промисификация setTimeout)</h3>
                <p>Давай создадим вспомогательную функцию <code>makePromise</code>, которая возвращает промис с заданной
                    задержкой, значением и состоянием (fulfilled или rejected). Это пример промисификации функции
                    <code>setTimeout</code>.
                </p>

                <p><strong>Задача:</strong><br>
                    Функция <code>makePromise(options)</code> должна:</p>
                <ul>
                    <li>Принимать объект <code>options</code> с полями:
                        <ul>
                            <li><code>value</code> — значение промиса (результат или ошибка).</li>
                            <li><code>delay</code> — задержка в миллисекундах.</li>
                            <li><code>shouldResolve</code> — булево значение: <code>true</code> для успешного выполнения
                                (fulfilled), <code>false</code> для ошибки (rejected). По умолчанию <code>true</code>.
                            </li>
                        </ul>
                    </li>
                    <li>Возвращать промис, который выполняется или отклоняется после заданной задержки.</li>
                </ul>

                <p>Шаг 1: Базовая структура промисифицированной функции</p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== makePromise: Шаг 1 (Базовая структура) =====
// Функция makePromise принимает объект options и возвращает Промис.
const makePromise = (options) => { // Принимаем объект options.
  // Возвращаем новый Промис.
  return new Promise((resolve, reject) => { // Передаем executor.
    // --- Здесь будет асинхронная логика с setTimeout ---
    // Внутри setTimeout() будем вызывать resolve() или reject().
  });
};

// Пока функция не делает ничего полезного, только возвращает промис в состоянии pending.
console.log("makePromise создан.");
// (Этот код сам по себе не выведет результат промиса без .then().catch())
</code></pre>
                    <div class="button-group">
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>

                <p>Шаг 2: Деструктуризация параметров и добавление логики с <code>setTimeout</code></p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== makePromise: Шаг 2 (Логика с setTimeout) =====
// Функция makePromise принимает объект options и возвращает Промис,
// который выполняется или отклоняется после задержки.
const makePromise = (options) => { // Принимаем объект options.
  // Используем деструктуризацию объекта options прямо в параметрах.
  // Извлекаем value, delay, shouldResolve. shouldResolve по умолчанию true.
  const { value, delay, shouldResolve = true } = options;

  console.log(`[makePromise] Создается промис с задержкой ${delay} мс, должен завершиться: ${shouldResolve ? 'успешно' : 'с ошибкой'}`);

  // Возвращаем новый Промис.
  return new Promise((resolve, reject) => { // Передаем executor.
    // --- Имитация асинхронной операции с задержкой ---
    // Используем setTimeout() для выполнения кода после 'delay' миллисекунд.
    setTimeout(() => { // Функция внутри setTimeout выполнится асинхронно, через 'delay' мс.
      // Этот код выполняется после задержки.
      // Проверяем, должен ли промис быть успешным (true) или отклоненным (false).
      if (shouldResolve) {
        // Если shouldResolve истинно, вызываем resolve() с переданным значением.
        resolve(value); // Промис перейдет в fulfilled с этим value.
        console.log(`   [makePromise] Промис выполнен успешно с значением: ${value}`);
      } else {
        // Если shouldResolve ложно, вызываем reject() с переданным значением (как причиной ошибки).
        reject(value); // Промис перейдет в rejected с этим value.
        console.log(`   [makePromise] Промис отклонен с ошибкой: ${value}`);
      }
    }, delay); // Задержка перед вызовом resolve() или reject().
  });
};

// Теперь makePromise можно использовать для создания промисов с задержкой.
// (Для тестирования нужны .then() и .catch() - см. Шаг 3)
console.log("Функция makePromise создана.");
</code></pre>
                    <div class="button-group">
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>

                <p>Шаг 3: Тестирование функции <code>makePromise</code></p>
                <p>Теперь мы можем использовать созданную функцию для создания и тестирования разных промисов с
                    задержкой.
                </p>
                <div class="code-block">
                    <pre><code class="language-javascript">// ===== makePromise: Шаг 3 (Тестирование) =====
// Функция для создания промиса с задержкой (из Шага 2).
const makePromise = ({ value, delay, shouldResolve = true }) => {
  console.log(`[makePromise] Создается промис с задержкой ${delay} мс, должен завершиться: ${shouldResolve ? 'успешно' : 'с ошибкой'}`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (shouldResolve) {
        resolve(value);
        console.log(`   [makePromise] Промис выполнен успешно с значением: ${value}`);
      } else {
        reject(value);
        console.log(`   [makePromise] Промис отклонен с ошибкой: ${value}`);
      }
    }, delay);
  });
};

// --- Тестируем разные промисы, созданные с помощью makePromise ---
console.log("Начинаем тестирование makePromise...");

// Тест 1: Успешный промис с задержкой 1000 мс.
makePromise({ value: "A", delay: 1000 }) // Создаем первый промис.
  .then((value) => console.log("Результат Тест 1 (.then):", value)) // Обрабатываем успех.
  .catch((error) => console.error("Ошибка Тест 1 (.catch):", error)); // Обрабатываем ошибку (не сработает).
// Этот промис завершится через ~1 секунду.

// Тест 2: Успешный промис с задержкой 3000 мс.
makePromise({ value: "B", delay: 3000 }) // Создаем второй промис.
  .then((value) => console.log("Результат Тест 2 (.then):", value))
  .catch((error) => console.error("Ошибка Тест 2 (.catch):", error));
// Этот промис завершится через ~3 секунды.

// Тест 3: Отклоненный промис с задержкой 2000 мс.
makePromise({ value: "C", delay: 2000, shouldResolve: false }) // Создаем третий промис. shouldResolve=false -> будет ошибка.
  .then((value) => console.log("Результат Тест 3 (.then):", value)) // Не сработает.
  .catch((error) => console.error("Ошибка Тест 3 (.catch):", error)); // Обрабатываем ошибку.
// Этот промис завершится с ошибкой через ~2 секунды.

console.log("Тестирование makePromise запущено. Результаты будут выведены асинхронно по мере завершения промисов.");
// Обратите внимание на порядок вывода в консоль!
</code></pre>
                    <div class="button-group">
                        <button class="run-code">Запустить пример</button>
                        <button class="copy-code">Скопировать</button>
                        <button class="toggle-code">Скрыть код</button>
                    </div>
                    <div class="output"></div>
                </div>
                <p>Результат в консоли (порядок вывода зависит от задержек):</p>
                <pre><code class="language-text">[makePromise] Создается промис с задержкой 1000 мс, должен завершиться: успешно
[makePromise] Создается промис с задержкой 3000 мс, должен завершиться: успешно
[makePromise] Создается промис с задержкой 2000 мс, должен завершиться: с ошибкой
Начинаем тестирование makePromise...
Тестирование makePromise запущено. Результаты будут выведены асинхронно по мере завершения промисов.
[makePromise] Промис выполнен успешно с значением: A // Через ~1 секунду
Результат Тест 1 (.then): A
[makePromise] Промис отклонен с ошибкой: C // Через ~2 секунды
Ошибка Тест 3 (.catch): C
[makePromise] Промис выполнен успешно с значением: B // Через ~3 секунды
Результат Тест 2 (.then): B</code></pre>
                <p><strong>Объяснение:</strong></p>
                <ul>
                    <li>Первый промис: выполняется через 1 секунду, возвращает "A" (fulfilled).</li>
                    <li>Второй промис: выполняется через 3 секунды, возвращает "B" (fulfilled).</li>
                    <li>Третий промис: отклоняется через 2 секунды, возвращает "C" (rejected).</li>
                    <li>Результаты <code>.then()</code> и <code>.catch()</code> срабатывают в порядке завершения
                        промисов, а
                        не в порядке их создания.</li>
                </ul>
            </section>
            <!-- Конец четвертого блока материала -->


            <!-- ============================================ -->
            <!-- СЮДА БУДУТ ДОБАВЛЕНЫ СЛЕДУЮЩИЕ БЛОКИ МАТЕРИАЛА -->
            <!-- ============================================ -->

        </main>
        <footer>
            <div class="container">
                <p>© 2025 JavaScript: Полное руководство для изучения. Все права защищены.</p>
            </div>
        </footer>
        <button id="scroll-top" aria-label="Прокрутить наверх" style="display: none;">↑</button>

        <!-- Подключение скриптов. Проверь пути! -->
        <script src="../main.js" defer></script>
        <!-- Скрипты Prism.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"
            defer></script>
        <!-- !!! ВАЖНО: Здесь НЕ должно быть других скриптов с DOM-логикой! -->
</body>

</html>