<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@700&family=Roboto:wght@400;500;600;700&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="stylesheet" href="../css/style.css" />
  <title>Циклы и Управление Потоком - Руководство по JavaScript</title>
</head>

<body>
  <div id="progress-bar"></div>

  <header>
    <div class="header-container">
      <div class="logo"></div>
      <a href="index.html">
        <h1>JavaScript</h1>
      </a>

      <button id="theme-toggle" aria-label="Переключить тему">
        Светлая тема
      </button>
      <!-- Кнопка бургер-меню (появляется на мобильных по CSS) -->
      <button id="menu-toggle" class="menu-toggle-btn" aria-label="Открыть меню" aria-expanded="false">
        ☰
      </button>

      <!-- Основная навигация -->
      <nav id="main-nav">
        <!-- Кнопка закрытия меню (появляется в модальном окне по CSS) -->
        <button id="menu-close" class="menu-close-btn" aria-label="Закрыть меню">
          ×
        </button>
        <!-- Убедитесь, что этот UL имеет ID -->
        <ul id="main-nav-list">
          <li><a href="../index.html">Главная</a></li>
          <li><a href="learning_guide.html">Гайд по обучению</a></li>
          <li><a href="basics.html">Основы и Деструктуризация</a></li>
          <li><a href="arrays.html">Массивы</a></li>
          <li><a href="functions.html">Функции</a></li>
          <li><a href="loops.html" class="active animate-neon-fill">Циклы</a></li>
          <li><a href="objects.html">Объекты</a></li>
          <li><a href="oop-classes.html">ООП и классы</a></li>
          <li><a href="modules4_page.html">JSON, Хранилище, Инструменты, Модули</a></li>
          <li><a href="exercises.html">Упражнения</a></li>
          <li><a href="projects.html">Проекты</a></li>
          <li><a href="resources.html">Ресурсы</a></li>
          <li><a href="dom_summary.html">Памятка по DOM</a></li>
          <li><a href="gallery.html">Галерея(пример)</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <main class="container">
    <h2 id="циклы-и-управление-потоком">Циклы и Управление Потоком</h2>
    <p><strong>Циклы</strong> — это конструкции, которые позволяют выполнять один и тот же блок кода многократно, пока
      выполняется определённое условие. Это фундаментальный инструмент для автоматизации повторяющихся задач.</p>
    <p><strong>Управление потоком</strong> включает в себя инструкции, которые позволяют изменять стандартный порядок
      выполнения кода, например, досрочно выходить из цикла (<code>break</code>) или пропускать итерацию
      (<code>continue</code>), а также обрабатывать ошибки (<code>try...catch</code>).</p>

    <section id="цикл-for" class="scroll-reveal visible">
      <h3>1. Цикл <code>for</code></h3>
      <p>Цикл <code>for</code> — самый распространенный вид цикла. Он идеально подходит, когда вы заранее знаете (или
        можете легко вычислить), сколько раз нужно повторить действие.</p>
      <p>Структура цикла <code>for</code>:</p>
      <code>for (инициализация; условие; шаг) { // тело цикла }</code>
      <ul>
        <li><strong>Инициализация:</strong> Выполняется один раз перед началом цикла (обычно здесь объявляют и
          инициализируют переменную-счетчик, например, <code>let i = 0</code>).</li>
        <li><strong>Условие:</strong> Проверяется перед каждой итерацией (повторением) цикла. Если условие истинно
          (<code>true</code>), тело цикла выполняется. Если ложно (<code>false</code>), цикл завершается. (Например,
          <code>i < 5</code>).
        </li>
        <li><strong>Шаг (Пост-выражение):</strong> Выполняется после каждой итерации тела цикла (обычно здесь изменяют
          счетчик, например, <code>i++</code>).</li>
        <li><strong>Тело цикла:</strong> Код, который выполняется на каждой итерации, пока условие истинно.</li>
      </ul>
      <div class="code-block">
        <pre><code class="language-javascript">// ===== ЦИКЛЫ И УПРАВЛЕНИЕ ПОТОКОМ В JAVASCRIPT =====
// Заголовок секции в консоли
console.log("===== ЦИКЛЫ И УПРАВЛЕНИЕ ПОТОКОМ =====");

// === Циклы for ===
// Подзаголовок для цикла for
console.log("\n--- Цикл for ---"); // '\n' добавляет пустую строку для читаемости

// --- Стандартный цикл for ---
// Классический пример: выполнить блок кода 5 раз.
console.log("Стандартный for:");
// 1. Инициализация: создать переменную 'i' и присвоить ей 0. Выполняется один раз.
// 2. Условие: проверять перед КАЖДОЙ итерацией, меньше ли 'i' чем 5. Если да - выполнить тело, если нет - выйти из цикла.
// 3. Шаг: после КАЖДОЙ итерации тела увеличить 'i' на 1 (i++).
for (let i = 0; i < 5; i++) { // Цикл будет выполняться для i = 0, 1, 2, 3, 4. Когда i станет 5, условие i < 5 будет ложным, цикл завершится.
  // Тело цикла: выполняется на каждой итерации.
  console.log(`  i = ${i}`); // Выводим текущее значение 'i'. Отступ для наглядности.
} // Конец тела цикла

// --- Цикл for с пропуском частей ---
// Можно опускать любую из трех частей (инициализацию, условие, шаг), но точки с запятой (;) обязательны.
let k = 0; // Инициализация переменной вне цикла.
console.log("For с пропуском инициализации и шага:");
// Пропускаем инициализацию (она уже сделана) и шаг (будет внутри тела).
for (; k < 3;) { // Условие: пока 'k' меньше 3.
  console.log(`  k = ${k}`); // Выводим 'k'.
  k++; // Шаг: увеличиваем 'k' вручную внутри тела. Цикл выполнится для k = 0, 1, 2.
}

// --- Цикл for для перебора массива ---
// Можно использовать 'for' для доступа к элементам массива по индексу.
// Однако, для этой цели циклы 'for...of' или метод 'forEach' обычно удобнее и читаемее.
const fruitsFor = ["яблоко", "банан", "апельсин"]; // Массив строк.
console.log("For для массива:");
// Инициализация: i = 0 (первый индекс массива).
// Условие: пока 'i' меньше длины массива (fruitsFor.length = 3). Индексы: 0, 1, 2.
// Шаг: i++ (переход к следующему индексу).
for (let i = 0; i < fruitsFor.length; i++) {
  // Доступ к элементу массива по текущему индексу 'i': fruitsFor[i].
  console.log(`  Фрукт ${i}: ${fruitsFor[i]}`); // Выводим индекс и значение элемента.
}</code></pre>
        <button class="run-code" data-example="for-loop">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="цикл-while-и-do-while" class="scroll-reveal visible">
      <h3>2. Циклы <code>while</code> и <code>do...while</code></h3>
      <p><strong>Цикл <code>while</code></strong> выполняет блок кода, <strong>пока</strong> заданное условие истинно
        (<code>true</code>). Условие проверяется <strong>перед</strong> каждой итерацией.</p>
      <code>while (условие) { // тело цикла }</code>
      <p><strong>Цикл <code>do...while</code></strong> похож на <code>while</code>, но с одним ключевым отличием: тело
        цикла выполняется <strong>хотя бы один раз</strong>, и только <strong>потом</strong> проверяется условие. Если
        условие истинно, цикл повторяется.</p>
      <code>do { // тело цикла } while (условие);</code>
      <p><code>do...while</code> полезен, когда нужно гарантированно выполнить действие минимум один раз, например, при
        запросе ввода от пользователя.</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Цикл while ===
// Подзаголовок для цикла while
console.log("\n--- Цикл while ---");
// Выполняется, пока условие истинно. Условие проверяется ПЕРЕД каждой итерацией.
// Если условие ложно с самого начала, тело цикла не выполнится ни разу.

let count = 0; // Инициализация счетчика.
console.log("Стандартный while:");
// Условие: выполнять цикл, пока 'count' меньше 3.
while (count < 3) {
  // Тело цикла:
  console.log(`  count = ${count}`); // Выводим текущее значение.
  count++; // ВАЖНО: Не забыть изменить переменную условия внутри цикла, иначе он станет бесконечным!
} // Цикл выполнится для count = 0, 1, 2.

// --- Пример while с break ---
// Иногда условие выхода удобнее проверять внутри цикла. Можно использовать `while(true)` и `break`.
let randomNum; // Переменная для случайного числа.
let attempts = 0; // Счетчик попыток.
console.log("While для случайного числа (с break):");
// Условие 'true' означает, что цикл сам по себе будет бесконечным.
while (true) {
  attempts++; // Увеличиваем счетчик попыток.
  randomNum = Math.random(); // Генерируем случайное число от 0 (включительно) до 1 (не включительно).
  // Выводим попытку и число (округляем до 2 знаков после запятой для читаемости).
  console.log(`  Попытка ${attempts}: ${randomNum.toFixed(2)}`);

  // Условие выхода из цикла:
  if (randomNum > 0.8) { // Если сгенерированное число больше 0.8,
    console.log(`  Найдено число > 0.8!`);
    break; // Ключевое слово 'break' немедленно прерывает выполнение ТЕКУЩЕГО цикла (в данном случае while).
  }

  // Защита от слишком долгого выполнения (хорошая практика для while(true)):
  if (attempts > 10) { // Если сделано больше 10 попыток,
    console.log("  Превышено число попыток.");
    break; // Тоже выходим из цикла, чтобы избежать зависания.
  }
} // Конец while

// === Цикл do...while ===
// Подзаголовок для do...while
console.log("\n--- Цикл do...while ---");
// Главное отличие от while: тело цикла выполняется ХОТЯ БЫ ОДИН РАЗ, и только ПОТОМ проверяется условие.

let choice; // Переменная для хранения "выбора".
do {
  // Тело цикла - выполняется ПЕРЕД первой проверкой условия.
  // Имитация запроса ввода у пользователя (в реальном коде здесь мог бы быть prompt).
  // choice = prompt("Введите 'выход', чтобы закончить:"); // Закомментировано для автоматического выполнения в среде без prompt.
  // Генерируем случайный выбор: с вероятностью ~30% будет 'выход', иначе 'продолжить'.
  choice = Math.random() > 0.7 ? 'выход' : 'продолжить';
  console.log(`  Ввод пользователя (имитация): ${choice}`); // Показываем имитированный ввод.
} while (choice !== 'выход'); // Условие: повторять цикл, пока 'choice' НЕ РАВЕН строке 'выход'. Проверяется ПОСЛЕ выполнения тела.
console.log("  Цикл do...while завершен."); // Этот код выполнится, когда choice станет 'выход'.
</code></pre>
        <button class="run-code" data-example="while-do-while">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="циклы-for-in-и-for-of" class="scroll-reveal visible">
      <h3>3. Циклы <code>for...of</code> и <code>for...in</code></h3>
      <p>Эти два цикла предоставляют более удобные способы перебора коллекций, но используются для разных целей:</p>
      <p><strong><code>for...of</code></strong> (предпочтительный для коллекций):</p>
      <ul>
        <li>Перебирает <strong>ЗНАЧЕНИЯ</strong> элементов.</li>
        <li>Работает с <strong>итерируемыми объектами</strong> (iterable objects): массивами, строками,
          <code>Map</code>, <code>Set</code>, NodeList (результат <code>document.querySelectorAll</code>) и др.
        </li>
        <li>Не работает с обычными объектами <code>{...}</code> напрямую (они не итерируемые по умолчанию).</li>
        <li>Это современный и самый удобный способ перебора элементов коллекций, когда не нужен индекс.</li>
      </ul>
      <code>for (const элемент of коллекция) { // используем элемент }</code>
      <p><strong><code>for...in</code></strong> (специфичный для объектов):</p>
      <ul>
        <li>Перебирает <strong>КЛЮЧИ</strong> (имена свойств) объекта.</li>
        <li>Работает с любыми объектами.</li>
        <li><strong>Внимание:</strong> Порядок перебора ключей <strong>не гарантирован</strong>!</li>
        <li><strong>Внимание:</strong> Перебирает не только собственные свойства объекта, но и
          <strong>унаследованные</strong> от прототипа. Часто это нежелательное поведение, требуется проверка
          <code>hasOwnProperty</code>.
        </li>
        <li><strong>Внимание:</strong> <strong>Не используйте <code>for...in</code> для перебора массивов!</strong> Он
          может перебирать не только числовые индексы, но и другие свойства, добавленные к массиву (что редко, но
          возможно), и порядок также не гарантирован.</li>
      </ul>
      <code>for (const ключ in объект) { // используем ключ, доступ к значению: объект[ключ] }</code>
      <div class="code-block">
        <pre><code class="language-javascript">// === Цикл for...of ===
// Подзаголовок для for...of
console.log("\n--- Цикл for...of ---");
// Предназначен для перебора ЗНАЧЕНИЙ итерируемых объектов.
// Итерируемые объекты - это те, чьи элементы можно перебрать по одному (массивы, строки, Map, Set и т.д.).

// --- Перебор массива ---
const colors = ["красный", "зеленый", "синий"]; // Наш массив.
console.log("for...of для массива:");
// 'const color' - объявляем переменную, в которую на каждой итерации будет попадать ОЧЕРЕДНОЕ ЗНАЧЕНИЕ из массива 'colors'.
for (const color of colors) {
  console.log(`  Цвет: ${color}`); // Выводим значение. Сначала "красный", потом "зеленый", потом "синий".
}

// --- Перебор строки ---
// Строки тоже итерируемые объекты, можно перебрать их символы.
const message = "Привет"; // Наша строка.
console.log("for...of для строки:");
// 'const char' - переменная для очередного СИМВОЛА строки 'message'.
for (const char of message) {
  console.log(`  Символ: ${char}`); // Выводим каждый символ строки по очереди: 'П', 'р', 'и', 'в', 'е', 'т'.
}

// --- Перебор Map ---
// Map - это коллекция пар [ключ, значение]. for...of перебирает эти пары.
const map = new Map([['a', 1], ['b', 2]]); // Создаем Map с двумя записями.
console.log("for...of для Map:");
// 'const entry of map' - 'entry' на каждой итерации будет МАССИВОМ из двух элементов: [ключ, значение].
// Мы можем сразу деструктурировать этот массив в переменные 'key' и 'value'.
for (const [key, value] of map) { // Удобный синтаксис для получения ключа и значения сразу.
  console.log(`  ${key} -> ${value}`); // Выводим ключ и значение.
}

// --- Перебор Set ---
// Set - это коллекция УНИКАЛЬНЫХ значений. for...of перебирает эти значения.
const set = new Set([1, 2, 2, 3, 1]); // Создаем Set. Дубликаты (вторые 2 и 1) будут проигнорированы. В Set будут только 1, 2, 3.
console.log("for...of для Set:");
// 'const num of set' - 'num' будет принимать уникальные значения из Set по очереди.
for (const num of set) {
  console.log(`  Значение: ${num}`); // Выведет 1, потом 2, потом 3 (порядок вставки обычно сохраняется).
}

// === Цикл for...in ===
// Подзаголовок для for...in
console.log("\n--- Цикл for...in ---");
// Предназначен для перебора КЛЮЧЕЙ (имен свойств) объекта.
// ВАЖНО: Использовать с осторожностью!

const person = { // Обычный объект.
  name: "Иван",
  age: 30,
  city: "Москва"
};
// Для демонстрации проблемы унаследованных свойств, добавим свойство в прототип ВСЕХ объектов.
// (В реальном коде так делать НЕ СЛЕДУЕТ!)
Object.prototype.inheritedProp = "Это унаследовано";

console.log("for...in для объекта (включая унаследованные):");
// 'const key in person' - 'key' на каждой итерации будет принимать ИМЯ СВОЙСТВА (ключ) объекта 'person'.
for (const key in person) {
  // 'key' будет строкой ('name', 'age', 'city', 'inheritedProp').
  // Доступ к значению свойства осуществляется через квадратные скобки: person[key].
  console.log(`  Ключ: ${key}, Значение: ${person[key]}`);
  // Заметьте, что 'inheritedProp' тоже вывелось!
}

// --- Перебор только СОБСТВЕННЫХ свойств объекта ---
// Чтобы избежать перебора унаследованных свойств, нужна проверка.
console.log("for...in только для собственных свойств:");
for (const key in person) {
  // Метод Object.hasOwnProperty.call(obj, key) проверяет, принадлежит ли свойство 'key' непосредственно объекту 'obj', а не его прототипу.
  // Использовать 'call' здесь - хорошая практика на случай, если у объекта 'person' есть свое свойство с именем 'hasOwnProperty'.
  if (Object.hasOwnProperty.call(person, key)) { // Если 'key' - это собственное свойство 'person'.
    console.log(`  Свой ключ: ${key}, Значение: ${person[key]}`); // Выводим его.
  } else { // Если свойство унаследовано.
    console.log(`  (Унаследованный ключ: ${key})`); // Просто сообщаем об этом.
  }
}
// Убираем добавленное свойство из прототипа, чтобы оно не мешало дальнейшим примерам.
delete Object.prototype.inheritedProp;

// Еще раз ВАЖНО:
// Внимание: Не используйте for...in для перебора массивов!
// Он может перебрать нечисловые ключи, если они были добавлены к массиву,
// и порядок перебора числовых индексов не гарантирован. Для массивов используйте for, forEach или for...of.
</code></pre>
        <button class="run-code" data-example="for-in-for-of">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="управление-циклами-break-и-continue" class="scroll-reveal visible">
      <h3>4. Управление циклами: <code>break</code> и <code>continue</code></h3>
      <p>Иногда нужно изменить стандартное поведение цикла:</p>
      <ul>
        <li><strong><code>break</code></strong>: Полностью <strong>прерывает</strong> выполнение текущего цикла
          (<code>for</code>, <code>while</code>, <code>do...while</code>, а также конструкции <code>switch</code>).
          Выполнение программы продолжается с инструкции, следующей сразу за циклом.</li>
        <li><strong><code>continue</code></strong>: Прерывает выполнение <strong>текущей итерации</strong> цикла и
          немедленно переходит к <strong>следующей итерации</strong>. Код в теле цикла после <code>continue</code> в
          данной итерации не выполняется.</li>
      </ul>
      <p>Также можно использовать <strong>метки (labels)</strong> совместно с <code>break</code> и <code>continue</code>
        для управления <strong>вложенными</strong> циклами (например, чтобы выйти сразу из внешнего цикла изнутри
        внутреннего).</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Управление циклами: break и continue ===
// Подзаголовок для break и continue
console.log("\n--- break и continue ---");

// --- break: досрочный выход из цикла ---
console.log("Пример с break:");
// Цикл 'for', который должен был бы пройти от 0 до 9.
for (let i = 0; i < 10; i++) {
  // Условие для досрочного выхода:
  if (i === 5) { // Когда 'i' достигнет значения 5,
    console.log("  Выход из цикла при i = 5");
    break; // Выполняем 'break'. Цикл немедленно прекращается.
  }
  console.log(`  i = ${i}`); // Этот код не выполнится для i = 5 и больше.
} // Цикл выполнится для i = 0, 1, 2, 3, 4.

// --- continue: переход к следующей итерации ---
console.log("Пример с continue:");
// Цикл 'for' от 0 до 4.
for (let i = 0; i < 5; i++) {
  // Условие для пропуска итерации:
  if (i % 2 === 0) { // Если 'i' - четное число (остаток от деления на 2 равен 0),
    console.log(`  Пропуск четного числа ${i}`);
    continue; // Выполняем 'continue'. Код ниже в этой итерации пропускается, и цикл переходит к следующему значению 'i' (сначала выполнится шаг i++).
  }
  // Этот код выполняется только для нечетных 'i'.
  console.log(`  Нечетное число i = ${i}`);
} // Выведет сообщения о пропуске для 0, 2, 4 и сообщения о нечетном числе для 1, 3.

// --- Метки (labels) для break/continue во вложенных циклах ---
// Метка - это идентификатор, за которым следует двоеточие (:), размещаемый перед циклом.
console.log("Пример с метками:");
// 'outerLoop:' - это метка для внешнего цикла.
outerLoop: for (let i = 1; i <= 3; i++) { // Внешний цикл.
  console.log(`Внешний цикл: i = ${i}`);
  // Внутренний цикл (без метки):
  for (let j = 1; j <= 3; j++) {
    console.log(`  Внутренний цикл: j = ${j}`);
    // Пример использования break с меткой:
    if (i === 2 && j === 2) { // Когда i=2 и j=2,
      console.log("    Прерываем ВНЕШНИЙ цикл (break outerLoop)");
      break outerLoop; // Выходим не из внутреннего, а сразу из ВНЕШНЕГО цикла с меткой 'outerLoop'.
    }
    // Пример использования continue с меткой:
    if (i === 1 && j === 1) { // Когда i=1 и j=1,
      console.log("    Переходим к след. итерации ВНЕШНЕГО цикла (continue outerLoop)");
      continue outerLoop; // Пропускаем остаток внутреннего цикла И остаток внешнего цикла для i=1, переходим сразу к i=2.
    }
    // Этот код во внутреннем цикле не выполнится, если сработает break или continue выше.
    // console.log(`    (продолжение внутреннего j=${j})`);
  } // Конец внутреннего цикла
  // Этот код во внешнем цикле не выполнится, если сработает break outerLoop или continue outerLoop во внутреннем цикле.
  // console.log(`(продолжение внешнего i=${i})`);
} // Конец внешнего цикла
</code></pre>
        <button class="run-code" data-example="break-continue">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="обработка-ошибок-try-catch" class="scroll-reveal visible">
      <h3>5. Обработка ошибок: <code>try...catch...finally</code></h3>
      <p>Во время выполнения программы могут возникать ошибки (исключения), которые могут прервать её работу.
        Конструкция <code>try...catch...finally</code> позволяет "перехватывать" такие ошибки и обрабатывать их,
        предотвращая "падение" скрипта.</p>
      <p>Структура:</p>
      <code>try { /* Код, который может вызвать ошибку */ } catch (error) { /* Код для обработки ошибки */ } finally { /* Код, который выполнится всегда */ }</code>
      <ul>
        <li><strong><code>try</code>:</strong> Блок, в который помещается потенциально "опасный" код.</li>
        <li><strong><code>catch (error)</code>:</strong> Этот блок выполняется, <strong>только если</strong> в блоке
          <code>try</code> произошла ошибка. Переменная <code>error</code> (имя может быть любым) содержит объект с
          информацией об ошибке (<code>error.name</code>, <code>error.message</code>, <code>error.stack</code>).
        </li>
        <li><strong><code>finally</code></strong> (необязательный): Этот блок выполняется <strong>всегда</strong> – и
          если в <code>try</code> была ошибка, и если её не было. Обычно используется для "очистки" ресурсов (например,
          закрытия файлов или сетевых соединений), независимо от результата выполнения <code>try</code>.</li>
      </ul>
      <p>Можно использовать <code>try...catch</code> (без <code>finally</code>) или <code>try...finally</code> (без
        <code>catch</code>).
      </p>
      <p>С помощью оператора <code>throw</code> можно самостоятельно генерировать (выбрасывать) ошибки.</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Обработка ошибок: try...catch...finally ===
// Подзаголовок для try...catch
console.log("\n--- try...catch...finally ---");

// Основной блок try...catch...finally
try {
  // 1. Блок try: сюда помещаем код, который МОЖЕТ вызвать ошибку.
  console.log("Начало блока try");

  // Примеры потенциальных ошибок (закомментированы):
  // Деление на ноль в JS не вызывает ошибку, а дает Infinity.
  // let result = 10 / 0; console.log(result); // Infinity
  // Обращение к несуществующей переменной вызовет ReferenceError:
  // console.log(nonExistentVariable);
  // Вызов метода у null или undefined вызовет TypeError:
  // let obj = null; obj.method();

  // Искусственное генерирование ошибки с помощью 'throw':
  // Мы создаем новый объект ошибки Error с сообщением.
  throw new Error("Произошла искусственная ошибка!");

  // Этот код НЕ выполнится, если в блоке try выше произошла ошибка (или был выполнен throw).
  console.log("Этот код (в try) не выполнится, если была ошибка выше.");

} catch (error) {
  // 2. Блок catch: выполняется ТОЛЬКО ЕСЛИ в блоке try произошла ошибка.
  // 'error' - это объект, содержащий информацию об ошибке.
  console.error("!!! Поймана ошибка в блоке catch !!!"); // Используем console.error для вывода ошибок.
  console.error("  Тип ошибки (error.name):", error.name); // Стандартное имя ошибки (напр., 'Error', 'ReferenceError', 'TypeError').
  console.error("  Сообщение (error.message):", error.message); // Сообщение, которое мы передали в new Error() или стандартное сообщение.
  // console.error("  Стек вызовов (error.stack):", error.stack); // Показывает путь вызовов функций, приведших к ошибке (полезно для отладки). Раскомментируйте, чтобы увидеть.

} finally {
  // 3. Блок finally: выполняется ВСЕГДА, независимо от того, была ошибка в try или нет.
  // Используется для кода, который должен выполниться в любом случае (например, закрытие ресурсов).
  console.log("Блок finally выполнен (выполняется всегда).");
}

// Выполнение программы продолжается ПОСЛЕ всей конструкции try...catch...finally.
console.log("Выполнение программы продолжается после try...catch.");

// --- Пример функции с безопасной обработкой JSON ---
// JSON.parse() выбрасывает ошибку, если строка не является валидным JSON.
// Обернем вызов в try...catch, чтобы функция не "падала", а возвращала null в случае ошибки.
function parseJsonSafe(jsonString) {
  console.log(`\nПопытка разбора JSON: "${jsonString}"`);
  try {
    // Пытаемся разобрать строку JSON.
    const data = JSON.parse(jsonString);
    // Если ошибки не было:
    console.log("  JSON успешно разобран:", data);
    return data; // Возвращаем результат разбора.
  } catch (error) {
    // Если JSON.parse() вызвал ошибку:
    console.error(`  Ошибка разбора JSON: ${error.message}`); // Выводим сообщение об ошибке.
    return null; // Возвращаем null, сигнализируя о неудаче.
  }
}

// Примеры использования безопасной функции:
parseJsonSafe('{"name": "Иван", "age": 30}'); // Валидный JSON -> успех.
parseJsonSafe('{"name": "Иван", age: 30}'); // Невалидный JSON (age без кавычек) -> ошибка поймана, вернет null.
parseJsonSafe('это не json'); // Невалидный JSON -> ошибка поймана, вернет null.
</code></pre>
        <button class="run-code" data-example="try-catch">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <div class="navigation-buttons">
      <a href="functions.html" class="button">← Функции</a>
      <a href="objects.html" class="button">Объекты →</a>
    </div>
  </main>

  <footer>
    <div class="container">
      <p>© 2025 JavaScript: Полное руководство для изучения. Все права защищены.</p>
    </div>
  </footer>

  <button id="scroll-top" style="display: none;">↑</button>

  <script src="../main.js" defer></script>

  <script src="../js/04_loops_and_control_flow.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>

</html>
<!-- ```

Я обновил HTML-файл `loops.html`, встроив в него код JavaScript с подробными пошаговыми комментариями к каждой строке,
как мы и договаривались. Теперь пользователи твоего сайта смогут видеть объяснения прямо рядом с примерами кода.

Посмотри, пожалуйста, все ли теперь так, как ты хот -->