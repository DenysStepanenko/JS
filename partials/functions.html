<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@700&family=Roboto:wght@400;500;600;700&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="stylesheet" href="../css/style.css" />
  <title>Функции - Руководство по JavaScript</title>
</head>

<body>
  <div id="progress-bar"></div>

  <header>
    <div class="container">
      <button id="theme-toggle">Светлая тема</button>
      <h1>JavaScript: Полное руководство для изучения</h1>
      <nav>
        <ul>
          <li><a href="../index.html">Главная</a></li>
          <li><a href="learning_guide.html">Гайд по обучению</a></li>
          <li><a href="basics.html">Основы</a></li>
          <li><a href="arrays.html">Массивы</a></li>
          <li><a href="functions.html" class="active">Функции</a></li>
          <li><a href="loops.html">Циклы</a></li>
          <li><a href="objects.html">Объекты</a></li>
          <li><a href="oop-classes.html">ООП и классы</a></li>
          <li><a href="exercises.html">Упражнения</a></li>
          <li><a href="projects.html">Проекты</a></li>
          <li><a href="resources.html">Ресурсы</a></li>
          <li><a href="dom_summary.html">Памятка по DOM</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <main class="container">
    <h2 id="функции">Функции</h2>
    <p>Функции в JavaScript - это блоки кода, которые можно вызывать многократно.</p>

    <section id="объявление-функций" class="fade-in">
      <h3>Объявление функций</h3>
      <p>Существует несколько способов объявить функцию:</p>
      <div class="code-block">
        <pre><code class="language-javascript">console.log("===== ФУНКЦИИ =====");
console.log("\n--- Объявление функций ---");

// Объявление функции (Function Declaration)
// Можно вызывать до объявления (hoisting)
console.log("Вызов greetDeclaration до объявления:", greetDeclaration("Мир"));

function greetDeclaration(name) {
  return `Привет (Declaration), ${name}!`;
}
console.log("Вызов greetDeclaration после объявления:", greetDeclaration("Вселенная"));

// Функциональное выражение (Function Expression)
// Нельзя вызывать до присваивания переменной
// console.log(greetExpression("Мир")); // Ошибка! greetExpression is not defined or not a function

const greetExpression = function (name) {
  return `Привет (Expression), ${name}!`;
};
console.log("Вызов greetExpression после присваивания:", greetExpression("Галактика"));

// Стрелочная функция (Arrow Function) - краткий синтаксис
// Также нельзя вызывать до присваивания
const greetArrow = (name) => `Привет (Arrow), ${name}!`;
console.log("Вызов greetArrow:", greetArrow("Планета"));

// Стрелочная функция с телом
const addArrow = (a, b) => {
  const result = a + b;
  return `Сумма ${a} и ${b} равна ${result}`;
};
console.log(addArrow(5, 7));</code></pre>
        <button class="run-code" data-example="function-declaration">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="параметры-функций" class="fade-in">
      <h3>Параметры функций</h3>
      <p>Функции могут принимать входные данные через параметры.</p>
      <div class="code-block">
        <pre><code class="language-javascript">console.log("\n--- Параметры функций ---");

// Параметры по умолчанию
function createUser(name = "Гость", age = 18, city = "Неизвестно") {
  return `Имя: ${name}, Возраст: ${age}, Город: ${city}`;
}

console.log("Параметры по умолчанию:");
console.log(createUser("Иван", 25, "Москва")); // Все аргументы переданы
console.log(createUser("Анна", 30));          // city будет по умолчанию
console.log(createUser("Петр"));              // age и city по умолчанию
console.log(createUser());                   // Все по умолчанию

// Объект arguments (устаревший, псевдомассив)
function showArgsLegacy() {
  console.log("Arguments (legacy):", arguments);
  console.log("Длина arguments:", arguments.length);
  // arguments не является настоящим массивом, нет методов вроде forEach
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    if (typeof arguments[i] === 'number') {
      sum += arguments[i];
    }
  }
  console.log("Сумма числовых аргументов (legacy):", sum);
}
showArgsLegacy(1, "hello", true, 5, 10);

// Rest-параметр (...) - современный способ собрать аргументы в массив
function sumRest(...numbers) {
  console.log("Rest параметр (numbers):", numbers); // Настоящий массив
  return numbers.reduce((total, current) => total + current, 0);
}
console.log("Сумма через Rest:", sumRest(1, 2, 3, 4)); // 10
console.log("Сумма через Rest (другой набор):", sumRest(10, 20)); // 30

// Комбинация обычных и Rest параметров
function multiplyFirstAndSumRest(multiplier, ...numbers) {
  const sumOfRest = numbers.reduce((sum, num) => sum + num, 0);
  return multiplier * sumOfRest;
}
console.log("multiplyFirstAndSumRest(2, 1, 2, 3):", multiplyFirstAndSumRest(2, 1, 2, 3)); // 2 * (1+2+3) = 12

// Деструктуризация параметров (объекты)
function displayPerson({ name, age, city = "Неизвестно", skills = [] }) {
  console.log(`--- Информация о человеке ---`);
  console.log(`  Имя: ${name}`);
  console.log(`  Возраст: ${age}`);
  console.log(`  Город: ${city}`);
  console.log(`  Навыки: ${skills.join(', ') || 'Нет данных'}`);
}

const personInfo = { name: "Иван", age: 30, city: "Москва", skills: ["JS", "HTML"] };
displayPerson(personInfo);
displayPerson({ name: "Анна", age: 25 }); // city и skills по умолчанию

// Деструктуризация параметров (массивы)
function displayCoordinates([x, y, z = 0]) {
  console.log(`Координаты: X=${x}, Y=${y}, Z=${z}`);
}
displayCoordinates([10, 20, 5]);
displayCoordinates([5, -3]); // z будет 0</code></pre>
        <button class="run-code" data-example="function-parameters">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="область-видимости-и-замыкания" class="fade-in">
      <h3>Область видимости и замыкания</h3>
      <p>Область видимости определяет, где в коде доступны переменные. Замыкания - это механизм, позволяющий функции
        "помнить" свое лексическое окружение.</p>
      <div class="code-block">
        <pre><code class="language-javascript">console.log("\n--- Область видимости и Замыкания ---");

// Глобальная, локальная (функциональная) и блочная область видимости
let globalVar = "Я глобальная"; // Глобальная

function scopeTest() {
  let functionVar = "Я функциональная"; // Локальная (функциональная)
  console.log("Внутри функции:", globalVar);
  console.log("Внутри функции:", functionVar);

  if (true) {
    let blockVar = "Я блочная (let)"; // Блочная
    const blockConst = "Я блочная (const)"; // Блочная
    var blockVarLegacy = "Я функциональная (var в блоке)"; // var не имеет блочной видимости!
    console.log("Внутри блока:", blockVar);
    console.log("Внутри блока:", blockConst);
  }
  console.log("Снаружи блока (var):", blockVarLegacy); // Доступно!
  // console.log(blockVar); // Ошибка! blockVar is not defined
  // console.log(blockConst); // Ошибка! blockConst is not defined
}
scopeTest();
// console.log(functionVar); // Ошибка! functionVar is not defined

// Замыкания (closures)
// Функция запоминает лексическое окружение, в котором она была создана
function createCounter() {
  let count = 0; // Эта переменная "замыкается"
  console.log("Счетчик создан!");

  return function increment() { // Внутренняя функция
    count++;
    console.log("Счетчик:", count);
    return count;
  };
}

const counter1 = createCounter(); // count = 0 для counter1
const counter2 = createCounter(); // count = 0 для counter2 (независимый)

counter1(); // Счетчик: 1
counter1(); // Счетчик: 2
counter2(); // Счетчик: 1 (независимый)
counter1(); // Счетчик: 3

// Пример практического использования замыканий: генератор приветствий
function createGreeting(greetingWord) {
  return function (name) {
    return `${greetingWord}, ${name}! Как дела?`;
  };
}

const sayHi = createGreeting("Привет");
const sayHello = createGreeting("Hello");

console.log(sayHi("Маша"));
console.log(sayHello("John"));</code></pre>
        <button class="run-code" data-example="scope-closures">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="рекурсия" class="fade-in">
      <h3>Рекурсия</h3>
      <p>Рекурсия — это когда функция вызывает саму себя. Важно иметь базовый случай (условие выхода), чтобы избежать
        бесконечного цикла.</p>
      <div class="code-block">
        <pre><code class="language-javascript">console.log("\n--- Рекурсия ---");
// Функция вызывает саму себя

// Факториал числа (n! = n * (n-1) * ... * 1)
function factorial(n) {
  if (n < 0) return "Не определен для отрицательных чисел";
  if (n === 0 || n === 1) {
    return 1; // Базовый случай (условие выхода)
  }
  return n * factorial(n - 1); // Рекурсивный вызов
}
console.log("Факториал 5:", factorial(5)); // 120
console.log("Факториал 0:", factorial(0)); // 1

// Числа Фибоначчи (0, 1, 1, 2, 3, 5, 8, ...)
// F(n) = F(n-1) + F(n-2)
function fibonacci(n) {
  if (n < 0) return "Не определен";
  if (n <= 1) {
    return n; // Базовые случаи: F(0)=0, F(1)=1
  }
  return fibonacci(n - 1) + fibonacci(n - 2); // Два рекурсивных вызова
}
console.log("Фибоначчи(7):", fibonacci(7)); // 13
// Внимание: рекурсивный Фибоначчи очень неэффективен для больших n!</code></pre>
        <button class="run-code" data-example="recursion">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="функции-высшего-порядка" class="fade-in">
      <h3>Функции высшего порядка (Higher-Order Functions)</h3>
      <p>Функции высшего порядка — это функции, которые либо принимают другие функции в качестве аргументов, либо
        возвращают функцию как результат.</p>
      <div class="code-block">
        <pre><code class="language-javascript">console.log("\n--- Функции высшего порядка ---");
// Функции, которые принимают другие функции как аргументы или возвращают их

// 1. Принятие функции как аргумента (callback)
function operateOnArray(arr, operation) {
  const result = [];
  for (const item of arr) {
    result.push(operation(item));
  }
  return result;
}
const numbersForHOF = [1, 2, 3, 4];
const doubleIt = (x) => x * 2;
const squareIt = (x) => x * x;

const doubledArray = operateOnArray(numbersForHOF, doubleIt);
const squaredArray = operateOnArray(numbersForHOF, squareIt);
console.log("Удвоенный массив:", doubledArray);
console.log("Квадраты чисел:", squaredArray);

// 2. Возврат функции из функции
function createPowerCalculator(exponent) {
  return function (base) {
    return Math.pow(base, exponent);
  };
}
const square = createPowerCalculator(2); // Функция возведения в квадрат
const cube = createPowerCalculator(3);   // Функция возведения в куб

console.log("square(5):", square(5)); // 25
console.log("cube(3):", cube(3));   // 27</code></pre>
        <button class="run-code" data-example="higher-order-functions">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="методы-функций-call-apply-bind" class="fade-in">
      <h3>Методы функций (call, apply, bind)</h3>
      <p>Эти методы позволяют управлять контекстом выполнения функции (<code>this</code>) и передавать аргументы.</p>
      <div class="code-block">
        <pre><code class="language-javascript">console.log("\n--- Методы функций (call, apply, bind) ---");

const person1 = { name: "Иван", city: "Москва" };
const person2 = { name: "Мария", city: "СПб" };

function introduce(greeting, punctuation) {
  console.log(`${greeting}, меня зовут ${this.name} из города ${this.city}${punctuation}`);
}

// call - вызывает функцию с указанным 'this' и аргументами через запятую
introduce.call(person1, "Привет", ".");
introduce.call(person2, "Здравствуйте", "!");

// apply - вызывает функцию с указанным 'this' и аргументами в виде массива
introduce.apply(person1, ["Добрый день", "..."]);
introduce.apply(person2, ["Bon jour", "!!!"]);

// bind - создает новую функцию с привязанным 'this' и, возможно, начальными аргументами
// Функция не вызывается сразу, а создается новая
const introduceIvan = introduce.bind(person1); // Привязываем this к person1
const introduceMariaWithHi = introduce.bind(person2, "Hi"); // Привязываем this и первый аргумент

introduceIvan("Всем привет", "."); // Вызываем новую функцию, передавая оставшиеся аргументы
introduceMariaWithHi("?"); // Вызываем другую новую функцию

// Пример с bind для методов объектов и потери контекста
const calculator = {
  value: 0,
  add(x) {
    this.value += x;
    console.log(`Значение: ${this.value}`);
  }
};

calculator.add(5); // Значение: 5

// const standaloneAdd = calculator.add;
// standaloneAdd(10); // Ошибка! Cannot read properties of undefined (reading 'value') - this потерян

const boundAdd = calculator.add.bind(calculator); // Привязываем this к calculator
boundAdd(10); // Значение: 15 (this теперь правильный)

// setTimeout(calculator.add, 1000, 20); // Ошибка this внутри setTimeout
setTimeout(calculator.add.bind(calculator), 100, 20); // Работает! Значение: 35</code></pre>
        <button class="run-code" data-example="function-methods">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="callback-functions" class="fade-in">
      <h2 id="колбэк-функции">Колбэк-функции (Callback Functions)</h2>
      <p>Теперь, когда мы знакомы с функциями высшего порядка, углубимся в понятие колбэков.</p>

      <section id="callback-function-as-value">
        <h3>1. Функция как значение (Повторение)</h3>
        <p>Как мы уже видели, функции можно передавать как значения.</p>
        <div class="code-block">
          <pre><code class="language-javascript">console.log("\n\n===== КОЛБЭК-ФУНКЦИИ =====");

// === Функция как значение (повтор для раздела) ===
console.log("\n--- Функция как значение (Callbacks) ---");
function greetCallbackExample(name) {
  return `Добро пожаловать, ${name}!`;
}
console.log("Вызов greetCallbackExample:", greetCallbackExample("Манго"));
console.log("Ссылка на greetCallbackExample:", greetCallbackExample);

function makePizzaTask1() {
  return "Ваша пицца готовится, пожалуйста, подождите.";
}
const resultPizza = makePizzaTask1();
const pointerPizza = makePizzaTask1;
console.log("Результат вызова makePizzaTask1:", resultPizza);
console.log("Ссылка на функцию makePizzaTask1:", pointerPizza);</code></pre>
          <button class="run-code" data-example="callback-as-value">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

      <section id="callback-definition">
        <h3>2. Колбэк-функции (Callback) - Определение</h3>
        <p><strong>Что это такое?</strong></p>
        <ul>
          <li><strong>Колбэк-функция (callback)</strong> — это функция, которую мы передаем в <em>другую</em> функцию
            как аргумент. Та, другая функция, затем <em>сама решает, когда и как вызвать</em> переданный ей колбэк.</li>
        </ul>
        <p><strong>Аналогия:</strong> Представь, ты даешь своему другу инструкцию (это колбэк-функция) и говоришь:
          "Выполни эту инструкцию, <em>когда</em> доставишь посылку". Твой друг (это основная функция) берет инструкцию
          и выполняет её в нужный момент (после доставки посылки).</p>
        <p><strong>Пример:</strong></p>
        <div class="code-block">
          <pre><code class="language-javascript">console.log("\n--- Колбэки и ФВП (Callbacks) ---");
function greetClb(name) {
  console.log(`Добро пожаловать, ${name}!`);
}
function notifyClb(name) {
  console.log(`Уважаемый(ая) ${name}, ваша комната будет готова через 30 минут`);
}
function registerGuestClb(name, callback) {
  console.log(`Регистрируем гостя ${name}!`);
  callback(name);
}
registerGuestClb("Манго", greetClb);
registerGuestClb("Поли", notifyClb);

function deliverPizzaClb(pizzaName) { return `Доставляем пиццу ${pizzaName}.`; }
function makePizzaClb(pizzaName) { return `Пицца ${pizzaName} готовится, подождите...`; }
function makeMessageClb(pizzaName, callback) {
  return callback(pizzaName);
}
console.log("Сообщение 1:", makeMessageClb("Роял Гранд", makePizzaClb));
console.log("Сообщение 2:", makeMessageClb("Ультрасыр", deliverPizzaClb));</code></pre>
          <button class="run-code" data-example="callback-definition">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

      <section id="inline-callbacks">
        <h3>3. Инлайн-колбеки (Inline Callbacks)</h3>
        <p>Если колбэк-функция простая и используется только один раз, её можно определить прямо "на месте" – внутри
          вызова основной функции (анонимно или с именем).</p>
        <div class="code-block">
          <pre><code class="language-javascript">console.log("\n--- Инлайн-колбеки (Callbacks) ---");
function registerGuestInline(name, callback) {
  console.log(`Регистрируем гостя ${name}! (inline)`);
  callback(name);
}
registerGuestInline("Манго", function (guestName) {
  console.log(`Добро пожаловать инлайн, ${guestName}!`);
});
registerGuestInline("Поли", function notifyInline(guestName) {
  console.log(`Комната готова инлайн через 30 мин, ${guestName}`);
});

function makePizzaInlineTask(pizzaName, callback) {
  console.log(`Готовим пиццу инлайн: ${pizzaName}`);
  callback(pizzaName);
}
makePizzaInlineTask("Ультрасыр", function eatPizza(nameOfPizza) {
  console.log(`Едим пиццу инлайн: ${nameOfPizza}`);
});</code></pre>
          <button class="run-code" data-example="inline-callbacks">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

      <section id="foreach-method-callback">
        <h3>4. Метод `forEach()` - Колбэки в действии!</h3>
        <p>Метод <code>forEach</code> позволяет выполнить действие для каждого элемента массива, используя колбэк.</p>
        <div class="code-block">
          <pre><code class="language-javascript">console.log("\n--- Метод forEach() (Callbacks) ---");
const numbersForEach = [5, 10, 15, 20, 25];
console.log("Массив для forEach:", numbersForEach);
console.log("Цикл for (сравнение):");
for (let i = 0; i < numbersForEach.length; i++) { console.log(`  Индекс ${i}, значение ${numbersForEach[i]}`); }
console.log("Метод forEach:");
numbersForEach.forEach(function (number, index) { console.log(`  Индекс ${index}, значение ${number}`); });

function calculateTotalPriceForEach(orderedItems) {
  let totalPrice = 0;
  orderedItems.forEach(function (item) { totalPrice += item; });
  return totalPrice;
}
console.log("Сумма [12, 85, 37, 4]:", calculateTotalPriceForEach([12, 85, 37, 4]));
console.log("Сумма [164, 48, 291]:", calculateTotalPriceForEach([164, 48, 291]));

function filterArrayForEach(numbers, value) {
  const filteredNumbers = [];
  numbers.forEach(function (number) {
    if (number > value) { filteredNumbers.push(number); }
  });
  return filteredNumbers;
}
console.log("Фильтр > 3 из [1, 2, 3, 4, 5]:", filterArrayForEach([1, 2, 3, 4, 5], 3));
console.log("Фильтр > 38 из [12, 24, 8, 41, 76]:", filterArrayForEach([12, 24, 8, 41, 76], 38));

console.log("\n===== КОНЕЦ РАЗДЕЛА ФУНКЦИИ (ПОКА ЧТО) =====");</code></pre>
          <button class="run-code" data-example="foreach-callback">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>
    </section>

    <div class="navigation-buttons">
      <a href="arrays.html" class="button">← Массивы</a>
      <a href="loops.html" class="button">Циклы →</a>
    </div>
  </main>

  <footer>
    <div class="container">
      <p>© 2025 JavaScript: Полное руководство для изучения</p>
    </div>
  </footer>

  <button id="scroll-top" style="display: none;">↑</button>

  <script src="../js/03_functions.js" defer></script>
  <script src="../main.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      Prism.highlightAll();
    });
  </script>
</body>

</html>