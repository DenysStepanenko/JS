<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@700&family=Roboto:wght@400;500;600;700&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="stylesheet" href="../css/style.css" />
  <title>Функции - Руководство по JavaScript</title>
</head>

<body>
  <div id="progress-bar"></div>

  <header>
    <div class="header-container">
      <div class="logo"></div>
      <a href="index.html">
        <h1>JavaScript</h1>
      </a>

      <button id="theme-toggle" aria-label="Переключить тему">
        Светлая тема
      </button>
      <!-- Кнопка бургер-меню (появляется на мобильных по CSS) -->
      <button id="menu-toggle" class="menu-toggle-btn" aria-label="Открыть меню" aria-expanded="false">
        ☰
      </button>

      <!-- Основная навигация -->
      <nav id="main-nav">
        <!-- Кнопка закрытия меню (появляется в модальном окне по CSS) -->
        <button id="menu-close" class="menu-close-btn" aria-label="Закрыть меню">
          ×
        </button>
        <!-- Убедитесь, что этот UL имеет ID -->
        <ul id="main-nav-list">
          <li><a href="../index.html">Главная</a></li>
          <li><a href="learning_guide.html">Гайд по обучению</a></li>
          <li><a href="basics.html">Основы и Деструктуризация</a></li>
          <li><a href="arrays.html">Массивы</a></li>
          <li><a href="functions.html" class="active animate-neon-fill">Функции</a></li>
          <li><a href="loops.html">Циклы</a></li>
          <li><a href="objects.html">Объекты</a></li>
          <li><a href="oop-classes.html">ООП и классы</a></li>
          <li><a href="modules4_page.html">JSON, Хранилище, Инструменты, Модули</a></li>
          <li><a href="exercises.html">Упражнения</a></li>
          <li><a href="projects.html">Проекты</a></li>
          <li><a href="resources.html">Ресурсы</a></li>
          <li><a href="dom_summary.html">Памятка по DOM</a></li>
          <li><a href="gallery.html">Галерея(пример)</a></li>
          <li><a href="async.html">Синхронность/Асинхронность</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <main class="container">
    <h2 id="функции">Функции</h2>
    <p>Функции в JavaScript - это блоки кода, которые можно определять один раз и вызывать (исполнять) многократно в
      разных частях программы. Они помогают организовать код, сделать его переиспользуемым и более читаемым.</p>

    <section id="объявление-функций" class="scroll-reveal visible">
      <h3>Объявление функций</h3>
      <p>Существует несколько основных способов объявить (создать) функцию в JavaScript:</p>
      <div class="code-block">
        <pre><code class="language-javascript">// ===== ФУНКЦИИ В JAVASCRIPT =====
// Этот комментарий просто обозначает начало секции про функции.
console.log("===== ФУНКЦИИ ====="); // Выводим в консоль заголовок секции, чтобы было легче ориентироваться в выводе.

// === Объявление функций ===
// Начинаем подсекцию, посвященную разным способам создания (объявления) функций.
console.log("\n--- Объявление функций ---"); // Выводим в консоль заголовок подсекции. '\n' создает новую строку перед текстом для лучшей читаемости.

// --- Объявление функции (Function Declaration) ---
// Это классический способ объявления функции.
// Особенность: такие функции "поднимаются" (hoisting), т.е. их можно вызывать в коде ДО того, как они были написаны.

// Пример вызова ДО объявления:
console.log("Вызов greetDeclaration до объявления:", greetDeclaration("Мир")); // Вызываем функцию greetDeclaration, передавая ей строку "Мир". Это сработает благодаря hoisting.

// Само объявление функции greetDeclaration:
function greetDeclaration(name) { // Ключевое слово 'function', имя функции 'greetDeclaration', в скобках параметр 'name', который она будет принимать.
  return `Привет (Declaration), ${name}!`; // Тело функции: возвращает строку приветствия, используя переданный 'name'. `${...}` - это шаблонная строка для вставки переменных.
} // Конец тела функции.

// Пример вызова ПОСЛЕ объявления:
console.log("Вызов greetDeclaration после объявления:", greetDeclaration("Вселенная")); // Вызываем ту же функцию, но уже после ее объявления. Передаем "Вселенная".

// --- Функциональное выражение (Function Expression) ---
// Это другой способ создать функцию: она создается и присваивается переменной.
// Особенность: такие функции НЕ поднимаются (hoisting). Их можно вызвать только ПОСЛЕ того, как переменной была присвоена эта функция.

// Попытка вызова ДО присваивания (закомментирована, чтобы не вызывать ошибку):
// console.log(greetExpression("Мир")); // Если раскомментировать эту строку, будет ошибка: greetExpression еще не является функцией на этом этапе.

// Создание функции и присваивание ее константе 'greetExpression':
const greetExpression = function (name) { // 'const' объявляет константу. 'function(name)' - это анонимная функция (без имени после 'function'), которая присваивается greetExpression.
  return `Привет (Expression), ${name}!`; // Тело функции: возвращает строку приветствия.
}; // Конец функционального выражения. Точка с запятой ставится, так как это присваивание.

// Вызов ПОСЛЕ присваивания:
console.log("Вызов greetExpression после присваивания:", greetExpression("Галактика")); // Теперь вызов работает, так как greetExpression содержит функцию.

// --- Стрелочная функция (Arrow Function) ---
// Это современный, более короткий синтаксис для создания функций. Особенно удобен для коротких функций.
// Особенность: как и Function Expression, стрелочные функции НЕ поднимаются (hoisting). У них также есть особенности с 'this' (об этом позже).

// Создание стрелочной функции и присваивание ее константе 'greetArrow':
const greetArrow = (name) => `Привет (Arrow), ${name}!`; // 'const' объявляет константу. '(name)' - параметр. '=>' - стрелка, отделяет параметры от тела. Если тело состоит из одного выражения, которое нужно вернуть, фигурные скобки {} и 'return' можно опустить.

// Вызов стрелочной функции:
console.log("Вызов greetArrow:", greetArrow("Планета")); // Вызываем функцию, присвоенную greetArrow.

// --- Стрелочная функция с телом ---
// Если стрелочной функции нужно выполнить несколько действий или она не возвращает значение сразу, используются фигурные скобки {}.

// Создание стрелочной функции 'addArrow' с явным телом:
const addArrow = (a, b) => { // '(a, b)' - параметры. '=> {' - начало тела функции.
  const result = a + b; // Внутри тела создаем переменную 'result' для хранения суммы.
  return `Сумма ${a} и ${b} равна ${result}`; // Явно используем 'return', чтобы вернуть строку с результатом.
}; // Конец тела функции.

// Вызов стрелочной функции с телом:
console.log(addArrow(5, 7)); // Вызываем функцию, передаем числа 5 и 7.</code></pre>
        <button class="run-code" data-example="function-declaration">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="параметры-функций" class="scroll-reveal visible">
      <h3>Параметры функций</h3>
      <p>Функции могут принимать входные данные (аргументы) через параметры, объявленные в скобках при создании функции.
        Это позволяет делать функции гибкими и переиспользуемыми.</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Параметры функций ===
// Начинаем подсекцию о том, как функции принимают данные (параметры и аргументы).
console.log("\n--- Параметры функций ---"); // Выводим заголовок подсекции в консоль.

// --- Параметры по умолчанию ---
// Можно задать значения для параметров, которые будут использоваться, если при вызове функции соответствующие аргументы не переданы.

// Объявление функции 'createUser' с параметрами по умолчанию:
function createUser(name = "Гость", age = 18, city = "Неизвестно") { // Если 'name' не передан, он будет "Гость". Если 'age' не передан - 18, 'city' - "Неизвестно".
  return `Имя: ${name}, Возраст: ${age}, Город: ${city}`; // Функция возвращает строку с информацией о пользователе.
}

// Примеры вызова функции 'createUser':
console.log("Параметры по умолчанию:"); // Поясняющий вывод в консоль.
console.log(createUser("Иван", 25, "Москва")); // Передаем все три аргумента. Значения по умолчанию не используются.
console.log(createUser("Анна", 30));          // Передаем 'name' и 'age'. 'city' возьмет значение по умолчанию ("Неизвестно").
console.log(createUser("Петр"));              // Передаем только 'name'. 'age' (18) и 'city' ("Неизвестно") возьмут значения по умолчанию.
console.log(createUser());                   // Не передаем аргументов. Все параметры ('name', 'age', 'city') возьмут значения по умолчанию.

// --- Объект arguments (устаревший, псевдомассив) ---
// Внутри *любой* обычной функции (НЕ стрелочной!) доступен специальный объект `arguments`. Он содержит все аргументы, переданные в функцию при вызове, даже если они не были объявлены в параметрах.
// `arguments` похож на массив (есть `length`, можно обращаться по индексу `arguments[i]`), но это НЕ настоящий массив (нет методов типа `forEach`, `map` и т.д.). Сейчас вместо него лучше использовать Rest-параметр.

// Объявление функции 'showArgsLegacy', использующей `arguments`:
function showArgsLegacy() { // У функции нет объявленных параметров.
  console.log("Arguments (legacy):", arguments); // Выводим сам объект arguments. Показывает все переданные аргументы.
  console.log("Длина arguments:", arguments.length); // Выводим количество переданных аргументов.
  // Попытка посчитать сумму числовых аргументов с помощью цикла for (т.к. forEach не работает):
  let sum = 0; // Инициализируем переменную для суммы.
  for (let i = 0; i < arguments.length; i++) { // Перебираем аргументы по индексу от 0 до длины - 1.
    if (typeof arguments[i] === 'number') { // Проверяем, является ли текущий аргумент числом.
      sum += arguments[i]; // Если число, добавляем его к сумме.
    }
  }
  console.log("Сумма числовых аргументов (legacy):", sum); // Выводим посчитанную сумму.
}
// Вызываем функцию с разными типами аргументов:
showArgsLegacy(1, "hello", true, 5, 10); // Передаем число, строку, boolean, и еще два числа.

// --- Rest-параметр (...) ---
// Современный способ собрать НЕОПРЕДЕЛЕННОЕ количество аргументов в НАСТОЯЩИЙ массив.
// Ставится перед ПОСЛЕДНИМ параметром функции. Собирает все *оставшиеся* аргументы.

// Объявление функции 'sumRest' с Rest-параметром 'numbers':
function sumRest(...numbers) { // Три точки '...' перед 'numbers' говорят: "собери все аргументы, которые сюда передадут, в массив с именем 'numbers'".
  console.log("Rest параметр (numbers):", numbers); // Выводим массив 'numbers'. Увидим, что это настоящий массив.
  // Используем метод массива 'reduce' для подсчета суммы всех элементов:
  return numbers.reduce((total, current) => total + current, 0); // 'reduce' сворачивает массив к одному значению. (total, current) => total + current - функция, добавляющая текущий элемент к аккумулятору 'total'. 0 - начальное значение 'total'.
}
// Примеры вызова 'sumRest':
console.log("Сумма через Rest:", sumRest(1, 2, 3, 4)); // Передаем 4 аргумента. Они попадут в массив 'numbers'. Результат: 10.
console.log("Сумма через Rest (другой набор):", sumRest(10, 20)); // Передаем 2 аргумента. Результат: 30.

// --- Комбинация обычных и Rest параметров ---
// Можно использовать обычные параметры, а Rest-параметр соберет все остальные. Rest должен быть последним!

// Объявление функции 'multiplyFirstAndSumRest':
function multiplyFirstAndSumRest(multiplier, ...numbers) { // 'multiplier' - обычный первый параметр. '...numbers' - Rest-параметр, соберет все аргументы НАЧИНАЯ СО ВТОРОГО.
  // Считаем сумму всех чисел, попавших в массив 'numbers':
  const sumOfRest = numbers.reduce((sum, num) => sum + num, 0); // Снова используем reduce для суммы.
  // Возвращаем результат умножения первого аргумента ('multiplier') на сумму остальных ('sumOfRest'):
  return multiplier * sumOfRest;
}
// Пример вызова:
console.log("multiplyFirstAndSumRest(2, 1, 2, 3):", multiplyFirstAndSumRest(2, 1, 2, 3)); // 2 попадет в 'multiplier', а [1, 2, 3] - в 'numbers'. Результат: 2 * (1+2+3) = 12.

// --- Деструктуризация параметров (объекты) ---
// Если функция ожидает получить объект в качестве аргумента, можно сразу "разобрать" (деструктурировать) этот объект на нужные свойства прямо в списке параметров. Это делает код чище.

// Объявление функции 'displayPerson' с деструктуризацией объекта в параметрах:
function displayPerson({ name, age, city = "Неизвестно", skills = [] }) { // Фигурные скобки {} в параметрах означают: "ожидаю объект, и из него мне нужны свойства 'name', 'age', 'city', 'skills'".
                                                                         // Можно также задать значения по умолчанию для свойств (city, skills), если их не будет в переданном объекте.
  console.log(`--- Информация о человеке ---`); // Вывод разделителя.
  console.log(`  Имя: ${name}`); // Выводим извлеченное имя.
  console.log(`  Возраст: ${age}`); // Выводим извлеченный возраст.
  console.log(`  Город: ${city}`); // Выводим извлеченный город (или значение по умолчанию).
  console.log(`  Навыки: ${skills.join(', ') || 'Нет данных'}`); // Выводим навыки. 'skills.join(', ')' объединяет массив в строку через запятую. '|| 'Нет данных'' выведет "Нет данных", если массив 'skills' пустой (или отсутствует).
}

// Создаем объект с информацией о человеке:
const personInfo = { name: "Иван", age: 30, city: "Москва", skills: ["JS", "HTML"] };
// Вызываем функцию, передавая объект:
displayPerson(personInfo); // Функция сама извлечет нужные свойства из personInfo.

// Вызываем функцию с объектом, где не все свойства есть:
displayPerson({ name: "Анна", age: 25 }); // Передаем объект только с name и age. 'city' и 'skills' возьмут значения по умолчанию из определения функции.

// --- Деструктуризация параметров (массивы) ---
// Аналогично объектам, можно деструктурировать массив, передаваемый в функцию.

// Объявление функции 'displayCoordinates' с деструктуризацией массива в параметрах:
function displayCoordinates([x, y, z = 0]) { // Квадратные скобки [] в параметрах означают: "ожидаю массив, первый элемент пойдет в 'x', второй в 'y', третий в 'z'".
                                             // Можно также задать значение по умолчанию для элемента (z = 0), если массив будет короче.
  console.log(`Координаты: X=${x}, Y=${y}, Z=${z}`); // Выводим извлеченные координаты.
}
// Вызываем функцию, передавая массив с тремя элементами:
displayCoordinates([10, 20, 5]); // x=10, y=20, z=5.

// Вызываем функцию, передавая массив с двумя элементами:
displayCoordinates([5, -3]); // x=5, y=-3. 'z' возьмет значение по умолчанию 0.</code></pre>
        <button class="run-code" data-example="function-parameters">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="область-видимости-и-замыкания" class="scroll-reveal visible">
      <h3>Область видимости и Замыкания</h3>
      <p><strong>Область видимости (Scope)</strong> определяет, где в вашем коде доступны переменные и функции. В
        JavaScript есть глобальная, функциональная и блочная области видимости.</p>
      <p><strong>Замыкания (Closures)</strong> - это мощный механизм JavaScript, когда внутренняя функция "запоминает"
        переменные из той области видимости, где она была создана (её лексического окружения), даже если внешняя функция
        уже завершила свою работу.</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Область видимости и замыкания ===
// Начинаем подсекцию про то, где в коде доступны переменные (область видимости) и что такое замыкания.
console.log("\n--- Область видимости и Замыкания ---"); // Выводим заголовок подсекции.

// --- Глобальная, локальная (функциональная) и блочная область видимости ---
// Область видимости определяет доступность переменных.

// Глобальная переменная: объявлена вне любых функций или блоков {}. Доступна везде.
let globalVar = "Я глобальная"; // 'let' объявляет переменную.

// Функция для демонстрации областей видимости:
function scopeTest() {
  // Локальная (функциональная) переменная: объявлена внутри функции. Доступна только внутри этой функции.
  let functionVar = "Я функциональная";
  console.log("Внутри функции:", globalVar); // Глобальные переменные доступны внутри функций.
  console.log("Внутри функции:", functionVar); // Локальные переменные доступны внутри своей функции.

  // Блочная область видимости: переменные, объявленные с 'let' или 'const' внутри блока кода {} (например, if, for, или просто блок), доступны только внутри этого блока.
  if (true) { // Создаем блок с помощью if(true).
    let blockVar = "Я блочная (let)"; // Доступна только внутри этого if.
    const blockConst = "Я блочная (const)"; // Доступна только внутри этого if.
    var blockVarLegacy = "Я функциональная (var в блоке)"; // Переменные, объявленные с 'var', НЕ имеют блочной видимости! Они имеют функциональную видимость, т.е. доступны во всей функции, где объявлен блок. Это старое поведение, лучше использовать let/const.
    console.log("Внутри блока:", blockVar); // Доступно.
    console.log("Внутри блока:", blockConst); // Доступно.
  } // Конец блока if.
  console.log("Снаружи блока (var):", blockVarLegacy); // Переменная, объявленная с 'var' внутри блока, доступна здесь!
  // Попытка доступа к блочным переменным снаружи блока (закомментировано, вызовет ошибку):
  // console.log(blockVar); // Ошибка! blockVar is not defined. blockVar не видна за пределами блока if.
  // console.log(blockConst); // Ошибка! blockConst is not defined. blockConst тоже не видна.
}
// Вызываем функцию для выполнения кода внутри нее:
scopeTest();
// Попытка доступа к локальной переменной функции снаружи (закомментировано, вызовет ошибку):
// console.log(functionVar); // Ошибка! functionVar is not defined. functionVar не видна за пределами функции scopeTest.

// --- Замыкания (closures) ---
// Замыкание – это комбинация функции и лексического окружения (переменных), в котором эта функция была объявлена. Проще говоря, внутренняя функция "помнит" переменные внешней функции, даже когда внешняя функция уже завершила свою работу.

// Функция 'createCounter', которая СОЗДАЕТ и ВОЗВРАЩАЕТ другую функцию:
function createCounter() {
  let count = 0; // Локальная переменная внешней функции 'createCounter'. Она будет "замкнута".
  console.log("Счетчик создан!"); // Сообщение о создании.

  // Возвращаем НОВУЮ функцию (внутреннюю, анонимную):
  return function increment() { // Эта внутренняя функция имеет доступ к 'count' из внешней функции.
    count++; // Увеличиваем 'count' из внешней функции.
    console.log("Счетчик:", count); // Выводим текущее значение 'count'.
    return count; // Возвращаем значение счетчика.
  };
} // Конец функции createCounter.

// Создаем первый счетчик:
const counter1 = createCounter(); // Вызываем createCounter(). Она создает свою 'count=0' и возвращает функцию increment, которая "помнит" именно эту 'count'. Мы сохраняем эту функцию в counter1.
// Создаем второй счетчик:
const counter2 = createCounter(); // Вызываем createCounter() СНОВА. Она создает СВОЮ НОВУЮ 'count=0' и возвращает ДРУГУЮ функцию increment, которая помнит свою, независимую 'count'. Сохраняем во второй переменной.

// Используем счетчики:
counter1(); // Вызываем функцию из counter1. Она увеличит свой count до 1. Вывод: Счетчик: 1.
counter1(); // Вызываем снова. Увеличит свой count до 2. Вывод: Счетчик: 2.
counter2(); // Вызываем функцию из counter2. Она увеличит СВОЙ count до 1. Вывод: Счетчик: 1. (Независимый от counter1).
counter1(); // Вызываем снова первый. Увеличит свой count до 3. Вывод: Счетчик: 3.

// --- Пример практического использования замыканий: генератор приветствий ---
// Функция 'createGreeting' принимает слово приветствия и возвращает НОВУЮ функцию, которая уже использует это слово для приветствия конкретного имени.

// Фабрика функций приветствия:
function createGreeting(greetingWord) { // Принимает слово приветствия ('Привет', 'Hello').
  // Возвращаем новую функцию, которая будет принимать имя:
  return function (name) { // Эта внутренняя функция "помнит" 'greetingWord' из внешней.
    return `${greetingWord}, ${name}! Как дела?`; // Формирует полное приветствие, используя замкнутое 'greetingWord' и переданное 'name'.
  };
}

// Создаем конкретные функции приветствия с помощью фабрики:
const sayHi = createGreeting("Привет"); // Создаем функцию, которая всегда будет начинать с "Привет". Она помнит "Привет".
const sayHello = createGreeting("Hello"); // Создаем другую функцию, которая всегда будет начинать с "Hello". Она помнит "Hello".

// Используем созданные функции:
console.log(sayHi("Маша")); // Вызываем sayHi, передаем имя "Маша". Получаем "Привет, Маша! Как дела?".
console.log(sayHello("John")); // Вызываем sayHello, передаем имя "John". Получаем "Hello, John! Как дела?".</code></pre>
        <button class="run-code" data-example="scope-closures">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="рекурсия" class="scroll-reveal visible">
      <h3>Рекурсия</h3>
      <p><strong>Рекурсия</strong> — это техника программирования, при которой функция вызывает саму себя для решения
        подзадачи. Это может быть элегантным решением для задач, которые можно разбить на более мелкие, однотипные
        части.</p>
      <p>Ключевые моменты рекурсии:</p>
      <ul>
        <li><strong>Базовый случай (Base Case):</strong> Условие, при котором функция перестает вызывать себя и
          возвращает конкретный результат. Это предотвращает бесконечный цикл вызовов.</li>
        <li><strong>Рекурсивный шаг (Recursive Step):</strong> Шаг, на котором функция вызывает саму себя с измененными
          данными, приближаясь к базовому случаю.</li>
      </ul>
      <div class="code-block">
        <pre><code class="language-javascript">// === Рекурсия ===
// Начинаем подсекцию про рекурсию.
console.log("\n--- Рекурсия ---"); // Выводим заголовок.
// Рекурсия - это когда функция вызывает саму себя для решения задачи.
// Важно: у рекурсивной функции должен быть "базовый случай" (условие выхода), чтобы она не вызывала себя бесконечно.

// --- Факториал числа ---
// Пример: расчет факториала (n! = n * (n-1) * ... * 1). Например, 5! = 5 * 4 * 3 * 2 * 1 = 120.
// Рекурсивная формула: n! = n * (n-1)! Базовые случаи: 0! = 1, 1! = 1.

// Рекурсивная функция для расчета факториала:
function factorial(n) {
  // Обработка некорректного ввода:
  if (n < 0) return "Не определен для отрицательных чисел";
  // Базовый случай (условие выхода из рекурсии):
  if (n === 0 || n === 1) { // Если n равно 0 или 1,
    return 1; // то факториал равен 1. Рекурсия останавливается.
  }
  // Рекурсивный шаг:
  return n * factorial(n - 1); // Функция возвращает n, умноженное на результат вызова САМОЙ СЕБЯ для числа (n-1).
}
// Примеры вызова:
console.log("Факториал 5:", factorial(5)); // Раскрытие: 5 * factorial(4) -> 5 * 4 * factorial(3) -> ... -> 5 * 4 * 3 * 2 * factorial(1) -> 5 * 4 * 3 * 2 * 1 = 120.
console.log("Факториал 0:", factorial(0)); // Сразу срабатывает базовый случай. Возвращает 1.

// --- Числа Фибоначчи ---
// Пример: последовательность Фибоначчи (0, 1, 1, 2, 3, 5, 8,...), где каждое следующее число - сумма двух предыдущих.
// Рекурсивная формула: F(n) = F(n-1) + F(n-2). Базовые случаи: F(0)=0, F(1)=1.

// Рекурсивная функция для расчета n-го числа Фибоначчи:
function fibonacci(n) {
  // Обработка некорректного ввода:
  if (n < 0) return "Не определен";
  // Базовые случаи (условия выхода):
  if (n <= 1) { // Если n равно 0 или 1,
    return n; // возвращаем само число n (F(0)=0, F(1)=1). Рекурсия останавливается.
  }
  // Рекурсивный шаг:
  return fibonacci(n - 1) + fibonacci(n - 2); // Функция возвращает сумму результатов ДВУХ вызовов САМОЙ СЕБЯ для (n-1) и (n-2).
}
// Пример вызова:
console.log("Фибоначчи(7):", fibonacci(7)); // F(7) = F(6) + F(5) -> ... -> много вызовов -> 13.
// Замечание о производительности:
// Внимание: эта рекурсивная реализация Фибоначчи ОЧЕНЬ неэффективна для больших 'n', так как много раз пересчитывает одни и те же значения. Для больших n лучше использовать итеративный подход (цикл) или мемоизацию.</code></pre>
        <button class="run-code" data-example="recursion">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="функции-высшего-порядка" class="scroll-reveal visible">
      <h3>Функции высшего порядка (Higher-Order Functions, HOF)</h3>
      <p><strong>Функции высшего порядка</strong> — это основа функционального программирования в JavaScript. Это такие
        функции, которые:</p>
      <ul>
        <li>Либо принимают другие функции в качестве аргументов (эти функции-аргументы часто называют
          <strong>колбэками</strong>).
        </li>
        <li>Либо возвращают новую функцию как результат своей работы.</li>
      </ul>
      <p>Это позволяет создавать более гибкий, абстрактный и переиспользуемый код.</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Функции высшего порядка (Higher-Order Functions, HOF) ===
// Начинаем подсекцию про функции высшего порядка.
console.log("\n--- Функции высшего порядка ---"); // Выводим заголовок.
// HOF - это функции, которые либо:
// 1. Принимают другие функции в качестве аргументов (такие аргументы-функции часто называют "колбэками" - callback).
// 2. Возвращают функцию в качестве результата.

// --- 1. Принятие функции как аргумента (callback) ---
// Пример: функция, которая применяет некоторую операцию (переданную как колбэк) к каждому элементу массива.

// Функция 'operateOnArray' принимает массив 'arr' и функцию 'operation':
function operateOnArray(arr, operation) { // 'operation' - это колбэк-функция.
  const result = []; // Создаем пустой массив для результатов.
  for (const item of arr) { // Перебираем каждый 'item' в массиве 'arr'.
    result.push(operation(item)); // Вызываем переданную функцию 'operation' для текущего 'item' и добавляем ее результат в массив 'result'.
  }
  return result; // Возвращаем массив с результатами.
}
// Исходный массив:
const numbersForHOF = [1, 2, 3, 4];
// Функции-операции, которые будем передавать как колбэки:
const doubleIt = (x) => x * 2; // Удваивает число.
const squareIt = (x) => x * x; // Возводит число в квадрат.

// Используем 'operateOnArray' с разными колбэками:
const doubledArray = operateOnArray(numbersForHOF, doubleIt); // Передаем массив и функцию удвоения.
const squaredArray = operateOnArray(numbersForHOF, squareIt); // Передаем массив и функцию возведения в квадрат.
console.log("Удвоенный массив:", doubledArray); // Вывод: [2, 4, 6, 8]
console.log("Квадраты чисел:", squaredArray); // Вывод: [1, 4, 9, 16]

// --- 2. Возврат функции из функции ---
// Пример: функция, которая создает и возвращает новую функцию для возведения числа в определенную степень. (Похоже на пример с замыканием createGreeting).

// Функция 'createPowerCalculator' принимает показатель степени 'exponent':
function createPowerCalculator(exponent) {
  // Она ВОЗВРАЩАЕТ новую анонимную функцию, которая будет принимать основание 'base':
  return function (base) { // Эта внутренняя функция "помнит" 'exponent' из внешней функции (замыкание).
    return Math.pow(base, exponent); // Использует встроенную функцию Math.pow() для возведения 'base' в степень 'exponent'.
  };
}
// Создаем конкретные функции-калькуляторы с помощью 'createPowerCalculator':
const square = createPowerCalculator(2); // Создаем функцию, которая будет возводить в квадрат (помнит exponent=2).
const cube = createPowerCalculator(3);   // Создаем функцию, которая будет возводить в куб (помнит exponent=3).

// Используем созданные функции:
console.log("square(5):", square(5)); // Вызываем square с основанием 5. Результат: 25.
console.log("cube(3):", cube(3));   // Вызываем cube с основанием 3. Результат: 27.</code></pre>
        <button class="run-code" data-example="higher-order-functions">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="методы-функций-call-apply-bind" class="scroll-reveal visible">
      <h3>Методы функций (call, apply, bind)</h3>
      <p>У каждой функции в JavaScript есть встроенные методы <code>call()</code>, <code>apply()</code> и
        <code>bind()</code>. Они позволяют:
      </p>
      <ul>
        <li>Явно указать, какой объект будет использоваться в качестве <strong>контекста <code>this</code></strong>
          внутри функции во время её вызова.</li>
        <li>Передать аргументы в функцию определённым образом.</li>
      </ul>
      <p>Это особенно полезно, когда нужно вызвать функцию в контексте конкретного объекта или когда функция передается
        как колбэк и теряет свой изначальный контекст <code>this</code>.</p>
      <div class="code-block">
        <pre><code class="language-javascript">// === Методы функций (call, apply, bind) ===
// Начинаем подсекцию про специальные методы, которые есть у всех функций в JavaScript. Они позволяют управлять контекстом `this` и передачей аргументов.
console.log("\n--- Методы функций (call, apply, bind) ---"); // Выводим заголовок.

// Объекты для примера, которые будут выступать в роли контекста `this`:
const person1 = { name: "Иван", city: "Москва" }; // Первый объект.
const person2 = { name: "Мария", city: "СПб" };   // Второй объект.

// Функция, которая использует `this` для доступа к свойствам объекта:
function introduce(greeting, punctuation) { // Принимает приветствие и знак препинания.
  // `this.name` и `this.city` будут ссылаться на свойства того объекта, который будет передан как контекст при вызове с помощью call/apply/bind.
  console.log(`${greeting}, меня зовут ${this.name} из города ${this.city}${punctuation}`);
}

// --- call ---
// Метод `call` вызывает функцию НЕМЕДЛЕННО.
// Первый аргумент `call` - это объект, который станет `this` внутри функции.
// Остальные аргументы `call` передаются в вызываемую функцию как ее аргументы, через запятую.

// Вызываем 'introduce' с контекстом 'person1' и аргументами "Привет", ".":
introduce.call(person1, "Привет", "."); // this внутри introduce будет person1. greeting="Привет", punctuation=".".
// Вызываем 'introduce' с контекстом 'person2' и аргументами "Здравствуйте", "!":
introduce.call(person2, "Здравствуйте", "!"); // this внутри introduce будет person2. greeting="Здравствуйте", punctuation="!".

// --- apply ---
// Метод `apply` тоже вызывает функцию НЕМЕДЛЕННО.
// Первый аргумент `apply` - это объект, который станет `this`.
// Второй аргумент `apply` - это МАССИВ (или псевдомассив), элементы которого передаются в вызываемую функцию как ее аргументы.

// Вызываем 'introduce' с контекстом 'person1' и аргументами из массива ["Добрый день", "..."]:
introduce.apply(person1, ["Добрый день", "..."]); // this=person1. greeting="Добрый день", punctuation="...".
// Вызываем 'introduce' с контекстом 'person2' и аргументами из массива ["Bon jour", "!!!"]:
introduce.apply(person2, ["Bon jour", "!!!"]); // this=person2. greeting="Bon jour", punctuation="!!!".

// --- bind ---
// Метод `bind` НЕ вызывает функцию сразу. Он СОЗДАЕТ НОВУЮ функцию ("привязанную").
// У этой новой функции контекст `this` будет НАВСЕГДА привязан к объекту, переданному первым аргументом в `bind`.
// Можно также "заранее" передать начальные аргументы функции (они будут подставлены первыми при вызове новой функции).

// Создаем новую функцию 'introduceIvan', где 'this' всегда будет 'person1':
const introduceIvan = introduce.bind(person1); // this привязан к person1. Аргументы пока не передаем.
// Создаем новую функцию 'introduceMariaWithHi', где 'this' всегда будет 'person2', а первый аргумент ('greeting') всегда будет "Hi":
const introduceMariaWithHi = introduce.bind(person2, "Hi"); // this привязан к person2, первый аргумент 'greeting' привязан к "Hi".

// Теперь вызываем эти НОВЫЕ функции:
introduceIvan("Всем привет", "."); // Вызываем 'introduceIvan'. this уже person1. Передаем оставшиеся аргументы ("Всем привет" -> greeting, "." -> punctuation).
introduceMariaWithHi("?"); // Вызываем 'introduceMariaWithHi'. this уже person2, greeting уже "Hi". Передаем оставшийся аргумент "?" -> punctuation.

// --- Пример с bind для методов объектов и потери контекста ---
// Часто `this` "теряется", когда метод объекта передается как колбэк (например, в setTimeout или обработчиках событий). `bind` помогает это исправить.

// Объект 'calculator' с методом 'add':
const calculator = {
  value: 0, // Свойство для хранения значения.
  add(x) { // Метод для добавления числа к value.
    this.value += x; // `this.value` здесь ссылается на calculator.value, когда метод вызывается через calculator.add().
    console.log(`Значение: ${this.value}`); // Выводим новое значение.
  }
};

// Обычный вызов метода - `this` правильный:
calculator.add(5); // Вызываем add через объект. this = calculator. Вывод: Значение: 5.

// Попытка сохранить метод в переменную и вызвать отдельно (закомментировано):
// const standaloneAdd = calculator.add; // Сохраняем ССЫЛКУ на функцию add в новую переменную.
// standaloneAdd(10); // Вызываем функцию БЕЗ объекта. В 'use strict' режиме 'this' будет undefined, иначе - глобальный объект (window/global). В любом случае, 'this' НЕ будет 'calculator'. Произойдет ОШИБКА при доступе к 'this.value'.

// Используем `bind` для создания новой функции с привязанным контекстом:
const boundAdd = calculator.add.bind(calculator); // Создаем НОВУЮ функцию boundAdd, у которой 'this' НАВСЕГДА привязан к объекту 'calculator'.
// Теперь вызываем привязанную функцию:
boundAdd(10); // Вызываем boundAdd. this внутри нее будет 'calculator'. Работает правильно. Вывод: Значение: 15.

// Пример с setTimeout (классическая проблема потери контекста):
// Попытка передать оригинальный метод calculator.add в setTimeout (закомментировано):
// setTimeout(calculator.add, 1000, 20); // setTimeout вызовет calculator.add через 1 секунду. Но он вызовет ее без контекста 'calculator', 'this' будет потерян (скорее всего window или undefined). ОШИБКА. Третий аргумент (20) setTimeout передаст как аргумент в вызываемую функцию.

// Правильный способ с использованием `bind`:
setTimeout(calculator.add.bind(calculator), 100, 20); // Мы передаем в setTimeout НЕ сам метод, а его ПРИВЯЗАННУЮ копию (где this=calculator). setTimeout вызовет эту копию через 100мс, передав ей аргумент 20. Все сработает. Вывод (через 100мс): Значение: 35 (15 + 20).</code></pre>
        <button class="run-code" data-example="function-methods">Запустить пример</button>
        <button class="copy-code">Скопировать</button>
        <button class="toggle-code">Скрыть код</button>
        <div class="output"></div>
      </div>
    </section>

    <section id="callback-functions" class="scroll-reveal visible">
      <h2 id="колбэк-функции">Колбэк-функции (Callback Functions)</h2>
      <p>Теперь, когда мы знакомы с функциями высшего порядка, углубимся в понятие <strong>колбэков (callback)</strong>.
        Это один из фундаментальных паттернов в JavaScript, особенно важный для асинхронных операций (о них позже) и
        обработки событий.</p>

      <section id="callback-function-as-value">
        <h3>1. Функция как значение (Повторение)</h3>
        <p>Ключевая идея, позволяющая использовать колбэки: в JavaScript функции являются "гражданами первого класса".
          Это значит, что их можно:</p>
        <ul>
          <li>Присваивать переменным.</li>
          <li>Передавать как аргументы в другие функции.</li>
          <li>Возвращать из других функций.</li>
        </ul>
        <div class="code-block">
          <pre><code class="language-javascript">// ===== КОД ИЗ РАЗДЕЛА КОЛБЭК-ФУНКЦИИ =====
// Начинаем секцию, посвященную колбэк-функциям (частично повторяет HOF, но фокусируется на колбэках).
console.log("\n\n===== КОЛБЭК-ФУНКЦИИ ====="); // Выводим заголовок секции. Двойной \n\n для большего отступа.

// === Функция как значение (повтор для раздела) ===
// Повторяем идею, что функции можно присваивать переменным и передавать.
console.log("\n--- Функция как значение (Callbacks) ---"); // Выводим заголовок подсекции.

// Пример функции:
function greetCallbackExample(name) { // Объявляем функцию.
  return `Добро пожаловать, ${name}!`; // Она возвращает строку.
}
// Вызов функции и вывод результата:
console.log("Вызов greetCallbackExample:", greetCallbackExample("Манго")); // Вызываем функцию, получаем результат.
// Вывод самой функции (ссылки на нее):
console.log("Ссылка на greetCallbackExample:", greetCallbackExample); // Выводим саму переменную, содержащую функцию. Консоль обычно показывает тело функции.

// Еще один пример функции:
function makePizzaTask1() { // Объявляем функцию.
  return "Ваша пицца готовится, пожалуйста, подождите."; // Возвращает строку.
}
// Сохраняем РЕЗУЛЬТАТ вызова функции в переменную:
const resultPizza = makePizzaTask1(); // Вызываем функцию, ее результат ("Ваша пицца...") сохраняется в resultPizza.
// Сохраняем ССЫЛКУ на саму функцию в переменную:
const pointerPizza = makePizzaTask1; // НЕ вызываем функцию (нет скобок). Просто копируем ссылку на нее в pointerPizza.
// Выводим результат:
console.log("Результат вызова makePizzaTask1:", resultPizza);
// Выводим ссылку на функцию:
console.log("Ссылка на функцию makePizzaTask1:", pointerPizza);</code></pre>
          <button class="run-code" data-example="callback-as-value">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

      <section id="callback-definition">
        <h3>2. Колбэк-функции (Callback) - Определение</h3>
        <p><strong>Что это такое?</strong></p>
        <ul>
          <li><strong>Колбэк-функция (callback)</strong> — это функция <code>A</code>, которую мы передаем в
            <em>другую</em> функцию <code>B</code> как аргумент. Функция <code>B</code> затем <em>сама решает, когда и
              как вызвать</em> переданный ей колбэк <code>A</code>.
          </li>
          <li>Функция <code>B</code>, которая принимает колбэк, называется <strong>функцией высшего порядка</strong>.
          </li>
        </ul>
        <p><strong>Аналогия:</strong> Представь, ты даешь своему другу инструкцию (это колбэк-функция <code>A</code>) и
          говоришь: "Выполни эту инструкцию, <em>когда</em> доставишь посылку". Твой друг (это основная функция
          <code>B</code>) берет инструкцию и выполняет её в нужный момент (после доставки посылки).
        </p>
        <p><strong>Пример:</strong></p>
        <div class="code-block">
          <pre><code class="language-javascript">// === Колбэки и ФВП (Callbacks) ===
// Подсекция, объясняющая, что такое колбэк на примере.
console.log("\n--- Колбэки и ФВП (Callbacks) ---"); // Выводим заголовок.

// Функции, которые будут использоваться как колбэки:
function greetClb(name) { // Первая функция-колбэк (наша инструкция "поприветствовать").
  console.log(`Добро пожаловать, ${name}!`); // Просто выводит приветствие.
}
function notifyClb(name) { // Вторая функция-колбэк (инструкция "уведомить").
  console.log(`Уважаемый(ая) ${name}, ваша комната будет готова через 30 минут`); // Выводит уведомление.
}

// Функция высшего порядка, которая принимает колбэк (наш "друг", регистрирующий гостя):
function registerGuestClb(name, callback) { // Принимает имя 'name' и функцию 'callback' (инструкцию).
  console.log(`Регистрируем гостя ${name}!`); // Выполняет какое-то основное действие (регистрация).
  // В нужный момент (здесь - сразу после регистрации) вызывает переданную инструкцию (колбэк):
  callback(name); // Вызывает переданную ей колбэк-функцию, передавая ей 'name'.
}

// Вызываем registerGuestClb, передавая разные колбэки (инструкции):
registerGuestClb("Манго", greetClb); // Даем инструкцию "поприветствовать" при регистрации Манго.
registerGuestClb("Поли", notifyClb); // Даем инструкцию "уведомить" при регистрации Поли.

// Еще пример с колбэками для пиццы:
function deliverPizzaClb(pizzaName) { return `Доставляем пиццу ${pizzaName}.`; } // Колбэк 1: инструкция "сообщить о доставке".
function makePizzaClb(pizzaName) { return `Пицца ${pizzaName} готовится, подождите...`; } // Колбэк 2: инструкция "сообщить о готовке".

// Функция высшего порядка, принимающая колбэк для формирования сообщения:
function makeMessageClb(pizzaName, callback) { // Принимает название пиццы и колбэк (инструкцию, что сообщить).
  // Вызывает колбэк с названием пиццы и возвращает его результат:
  return callback(pizzaName);
}

// Вызываем makeMessageClb с разными колбэками (инструкциями):
console.log("Сообщение 1:", makeMessageClb("Роял Гранд", makePizzaClb)); // Просим сообщить о готовке.
console.log("Сообщение 2:", makeMessageClb("Ультрасыр", deliverPizzaClb)); // Просим сообщить о доставке.</code></pre>
          <button class="run-code" data-example="callback-definition">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

      <section id="inline-callbacks">
        <h3>3. Инлайн-колбеки (Inline Callbacks)</h3>
        <p>Если колбэк-функция простая и используется только один раз в конкретном месте, её необязательно объявлять
          отдельно с помощью <code>function имя() {...}</code>. Вместо этого её можно определить прямо "на месте" –
          внутри вызова основной функции. Это называется <strong>инлайн-колбэк</strong>.</p>
        <p>Инлайн-колбэки могут быть:</p>
        <ul>
          <li><strong>Анонимными:</strong> <code>function (параметры) { ... }</code> или
            <code>(параметры) => { ... }</code>
          </li>
          <li><strong>Именованными (редко):</strong> <code>function имяКолбэка(параметры) { ... }</code> (имя полезно
            для отладки, но обычно не используется).</li>
        </ul>
        <div class="code-block">
          <pre><code class="language-javascript">// === Инлайн-колбеки (Callbacks) ===
// Подсекция o том, что колбэк-функцию можно определять прямо внутри вызова основной функции (инлайн).
console.log("\n--- Инлайн-колбеки (Callbacks) ---"); // Выводим заголовок.

// Функция высшего порядка (та же, что и раньше):
function registerGuestInline(name, callback) {
  console.log(`Регистрируем гостя ${name}! (inline)`); // Основное действие.
  callback(name); // Вызов колбэка.
}

// Вызов registerGuestInline с АНОНИМНЫМ инлайн-колбэком (Function Expression):
registerGuestInline("Манго", function (guestName) { // Вместо имени функции передаем 'function(...) {...}' прямо здесь.
  // Это тело нашего колбэка:
  console.log(`Добро пожаловать инлайн, ${guestName}!`);
}); // Конец вызова registerGuestInline.

// Вызов registerGuestInline с ИМЕНОВАННЫМ инлайн-колбэком (имя 'notifyInline' полезно для стека вызовов при ошибках):
registerGuestInline("Поли", function notifyInline(guestName) { // Можно дать имя инлайн-функции.
  // Тело колбэка:
  console.log(`Комната готова инлайн через 30 мин, ${guestName}`);
}); // Конец вызова.

// Еще пример с инлайн-колбэком для пиццы (используем стрелочную функцию для краткости):
function makePizzaInlineTask(pizzaName, callback) { // Функция ВП.
  console.log(`Готовим пиццу инлайн: ${pizzaName}`); // Основное действие.
  callback(pizzaName); // Вызов колбэка.
}

// Вызов с анонимным стрелочным инлайн-колбэком:
makePizzaInlineTask("Ультрасыр", (nameOfPizza) => { // Определяем колбэк прямо тут с помощью '=>'.
  // Тело колбэка:
  console.log(`Едим пиццу инлайн: ${nameOfPizza}`);
});</code></pre>
          <button class="run-code" data-example="inline-callbacks">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

      <section id="foreach-method-callback">
        <h3>4. Метод `forEach()` - Колбэки в действии!</h3>
        <p>Метод <code>forEach</code>, доступный у массивов, является классическим примером использования колбэков. Он
          позволяет выполнить определенное действие (заданное колбэк-функцией) для <strong>каждого</strong> элемента
          массива по очереди.</p>
        <p>Синтаксис: <code>массив.forEach(function(элемент, индекс, самМассив) { ... });</code></p>
        <ul>
          <li><code>элемент</code>: Текущий обрабатываемый элемент массива.</li>
          <li><code>индекс</code> (необязательно): Индекс текущего элемента.</li>
          <li><code>самМассив</code> (необязательно): Ссылка на массив, по которому идет перебор.</li>
        </ul>
        <div class="code-block">
          <pre><code class="language-javascript">// === Метод forEach() (Callbacks) ===
// Подсекция о методе массива `forEach` как примере использования колбэков.
console.log("\n--- Метод forEach() (Callbacks) ---"); // Выводим заголовок.

// Исходный массив:
const numbersForEach = [5, 10, 15, 20, 25];
console.log("Массив для forEach:", numbersForEach); // Выводим массив.

// Для сравнения: как бы мы перебрали массив с помощью обычного цикла 'for':
console.log("Цикл for (сравнение):");
for (let i = 0; i < numbersForEach.length; i++) { // Стандартный цикл for с индексом.
  console.log(`  Индекс ${i}, значение ${numbersForEach[i]}`); // Выводим индекс и значение элемента.
}

// Использование метода `forEach`:
console.log("Метод forEach:");
// Метод forEach вызывается у массива. Он принимает КОЛБЭК-функцию в качестве аргумента.
// Этот колбэк будет вызван для КАЖДОГО элемента массива.
numbersForEach.forEach(function (number, index, array) { // Передаем анонимную инлайн-функцию как колбэк.
  // forEach передает в колбэк три аргумента:
  // 1. 'number' - текущий обрабатываемый элемент массива (5, потом 10, потом 15...).
  // 2. 'index' - индекс текущего элемента (0, потом 1, потом 2...).
  // 3. 'array' - ссылка на сам массив numbersForEach (редко используется).
  // Внутри колбэка мы решаем, что делать с каждым элементом:
  console.log(`  Индекс ${index}, значение ${number}`); // Выводим индекс и значение.
  // console.log(array); // Можно раскомментировать, чтобы увидеть массив на каждой итерации.
}); // Конец вызова forEach.

// --- Пример использования forEach для подсчета суммы ---
function calculateTotalPriceForEach(orderedItems) { // Функция принимает массив чисел.
  let totalPrice = 0; // Инициализируем сумму.
  // Используем forEach для перебора массива и накопления суммы:
  orderedItems.forEach(function (item) { // Колбэк принимает текущий элемент 'item'. Индекс и массив нам здесь не нужны.
    // Действие для каждого элемента: добавить его к общей сумме.
    totalPrice += item;
  });
  // После того, как forEach обойдет все элементы, возвращаем результат:
  return totalPrice;
}
// Примеры вызова:
console.log("Сумма [12, 85, 37, 4]:", calculateTotalPriceForEach([12, 85, 37, 4])); // Вывод: 138
console.log("Сумма [164, 48, 291]:", calculateTotalPriceForEach([164, 48, 291])); // Вывод: 503

// --- Пример использования forEach для фильтрации ---
// (Хотя для фильтрации есть более подходящий метод `filter`, forEach тоже можно использовать)
function filterArrayForEach(numbers, value) { // Принимает массив 'numbers' и пороговое значение 'value'.
  const filteredNumbers = []; // Создаем пустой массив для отфильтрованных элементов.
  // Перебираем исходный массив с помощью forEach:
  numbers.forEach(function (number) { // Колбэк получает текущее число 'number'.
    // Действие для каждого элемента: проверить условие.
    if (number > value) { // Если число больше порогового значения,
      filteredNumbers.push(number); // то добавить его в новый массив.
    }
  });
  // После обхода всех элементов возвращаем новый, отфильтрованный массив:
  return filteredNumbers;
}
// Примеры вызова:
console.log("Фильтр > 3 из [1, 2, 3, 4, 5]:", filterArrayForEach([1, 2, 3, 4, 5], 3)); // Оставит [4, 5].
console.log("Фильтр > 38 из [12, 24, 8, 41, 76]:", filterArrayForEach([12, 24, 8, 41, 76], 38)); // Оставит [41, 76].</code></pre>
          <button class="run-code" data-example="foreach-callback">Запустить пример</button>
          <button class="copy-code">Скопировать</button>
          <button class="toggle-code">Скрыть код</button>
          <div class="output"></div>
        </div>
      </section>

    </section>
  </main>

  <footer>
    <div class="container">
      <p>&copy; 2025 JavaScript: Полное руководство для изучения. Все права защищены.</p>
    </div>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

  <script src="../main.js"></script>

  <script src="../js/03_functions.js"></script>

</body>

</html>